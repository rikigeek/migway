//
// Ce fichier a été généré par l'implémentation de référence JavaTM Architecture for XML Binding (JAXB), v2.2.8-b130911.1802 
// Voir <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Toute modification apportée à ce fichier sera perdue lors de la recompilation du schéma source. 
// Généré le : 2016.05.30 à 11:09:47 AM CEST 
//


package org.ieee.standards.ieee1516_2010;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyAttribute;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlID;
import javax.xml.bind.annotation.XmlIDREF;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import javax.xml.namespace.QName;


/**
 * <p>Classe Java pour serviceUtilizationType complex type.
 * 
 * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
 * 
 * <pre>
 * &lt;complexType name="serviceUtilizationType">
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;all>
 *         &lt;element name="connect" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.2" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="disconnect" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.3" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="connectionLost" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.4" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="createFederationExecution" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.5" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="destroyFederationExecution" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.6" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="listFederationExecutions" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.7" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="reportFederationExecutions" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.8" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="joinFederationExecution" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.9" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="resignFederationExecution" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.10" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="registerFederationSynchronizationPoint" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.11" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="confirmSynchronizationPointRegistration" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.12" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="announceSynchronizationPoint" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.13" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="synchronizationPointAchieved" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.14" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="federationSynchronized" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.15" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="requestFederationSave" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.16" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="initiateFederateSave" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.17" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="federateSaveBegun" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.18" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="federateSaveComplete" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.19" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="federationSaved" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.20" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="abortFederationSave" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.21" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="queryFederationSaveStatus" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.22" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="federationSaveStatusResponse" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.23" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="requestFederationRestore" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.24" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="confirmFederationRestorationRequest" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.25" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="federationRestoreBegun" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.26" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="initiateFederateRestore" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.27" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="federateRestoreComplete" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.28" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="federationRestored" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.29" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="abortFederationRestore" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.30" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="queryFederationRestoreStatus" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.31" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="federationRestoreStatusResponse" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.32" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="publishObjectClassAttributes" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.2" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="unpublishObjectClassAttributes" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.3" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="publishInteractionClass" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.4" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="unpublishInteractionClass" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.5" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="subscribeObjectClassAttributes" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.6" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="unsubscribeObjectClassAttributes" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.7" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="subscribeInteractionClass" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.8" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="unsubscribeInteractionClass" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.9" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="startRegistrationForObjectClass" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.10" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="stopRegistrationForObjectClass" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.11" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="turnInteractionsOn" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.12" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="turnInteractionsOff" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.13" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="reserveObjectInstanceName" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.2" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="objectInstanceNameReserved" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.3" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="releaseObjectInstanceName" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.4" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="reserveMultipleObjectInstanceNames" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.5" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="multipleObjectInstanceNamesReserved" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.6" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="releaseMultipleObjectInstanceNames" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.7" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="registerObjectInstance" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.8" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="discoverObjectInstance" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.9" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="updateAttributeValues" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.10" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="reflectAttributeValues" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.11" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="sendInteraction" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.12" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="receiveInteraction" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.13" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="deleteObjectInstance" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.14" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="removeobjectinstance" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.15" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="localDeleteObjectInstance" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.16" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="attributesInScope" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.17" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="attributesOutOfScope" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.18" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="requestAttributeValueUpdate" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.19" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="provideAttributeValueUpdate" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.20" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="turnUpdatesOnForObjectInstance" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.21" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="turnUpdatesOffForObjectInstance" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.22" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="requestAttributeTransportationTypeChange" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.23" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="confirmAttributeTransportationTypeChange" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.24" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="queryAttributeTransportationType" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.25" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="reportAttributeTransportationType" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.26" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="requestInteractionTransportationTypeChange" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.27" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="confirmInteractionTransportationTypeChange" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.28" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="queryInteractionTransportationType" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.29" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="reportInteractionTransportationType" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.30" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="unconditionalAttributeOwnershipDivestiture" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.2" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="negotiatedAttributeOwnershipDivestiture" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.3" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="requestAttributeOwnershipAssumption" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.4" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="requestDivestitureConfirmation" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.5" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="confirmDivestiture" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.6" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="attributeOwnershipAcquisitionNotification" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.7" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="attributeOwnershipAcquisition" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.8" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="attributeOwnershipAcquisitionIfAvailable" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.9" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="attributeOwnershipUnavailable" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.10" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="requestAttributeOwnershipRelease" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.11" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="attributeOwnershipReleaseDenied" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.12" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="attributeOwnershipDivestitureIfWanted" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.13" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="cancelNegotiatedAttributeOwnershipDivestiture" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.14" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="cancelAttributeOwnershipAcquisition" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.15" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="confirmAttributeOwnershipAcquisitionCancellation" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.16" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="queryAttributeOwnership" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.17" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="informAttributeOwnership" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.18" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="isAttributeOwnedByFederate" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.19" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="enableTimeRegulation" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.2" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="timeRegulationEnabled" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.3" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="disableTimeRegulation" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.4" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="enableTimeConstrained" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.5" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="timeConstrainedEnabled" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.6" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="disableTimeConstrained" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.7" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="timeAdvanceRequest" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.8" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="timeAdvanceRequestAvailable" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.9" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="nextMessageRequest" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.10" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="nextMessageRequestAvailable" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.11" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="flushQueueRequest" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.12" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="timeAdvanceGrant" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.13" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="enableAsynchronousDelivery" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.14" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="disableAsynchronousDelivery" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.15" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="queryGALT" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.16" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="queryLogicalTime" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.17" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="queryLITS" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.18" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="modifyLookahead" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.19" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="queryLookahead" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.20" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="retract" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.21" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="requestRetraction" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.22" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="changeAttributeOrderType" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.23" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="changeInteractionOrderType" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.24" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="createRegion" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.2" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="commitRegionModifications" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.3" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="deleteRegion" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.4" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="registerObjectInstanceWithRegions" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.5" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="associateRegionsForUpdates" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.6" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="unassociateRegionsForUpdates" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.7" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="subscribeObjectClassAttributesWithRegions" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.8" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="unsubscribeObjectClassAttributesWithRegions" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.9" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="subscribeInteractionClassWithRegions" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.10" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="unsubscribeInteractionClassWithRegions" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.11" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="sendInteractionWithRegions" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.12" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="requestAttributeValueUpdateWithRegions" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.13" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getAutomaticResignDirective" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.2" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="setAutomaticResignDirective" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.3" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getFederateHandle" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.4" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getFederateName" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.5" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getObjectClassHandle" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.6" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getObjectClassName" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.7" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getKnownObjectClassHandle" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.8" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getObjectInstanceHandle" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.9" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getObjectInstanceName" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.10" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getAttributeHandle" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.11" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getAttributeName" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.12" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getUpdateRateValue" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.13" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getUpdateRateValueForAttribute" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.14" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getInteractionClassHandle" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.15" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getInteractionClassName" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.16" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getParameterHandle" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.17" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getParameterName" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.18" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getOrderType" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.19" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getOrderName" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.20" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getTransportationTypeHandle" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.21" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getTransportationTypeName" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.22" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getAvailableDimensionsForClassAttribute" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.23" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getAvailableDimensionsForInteractionClass" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.24" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getDimensionHandle" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.25" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getDimensionName" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.26" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getDimensionUpperBound" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.27" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getDimensionHandleSet" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.28" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="getRangeBounds" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.29" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="setRangeBounds" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.30" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="normalizeFederateHandle" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.31" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="normalizeServiceGroup" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.32" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="enableObjectClassRelevanceAdvisorySwitch" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.33" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="disableObjectClassRelevanceAdvisorySwitch" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.34" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="enableAttributeRelevanceAdvisorySwitch" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.35" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="disableAttributeRelevanceAdvisorySwitch" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.36" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="enableAttributeScopeAdvisorySwitch" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.37" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="disableAttributeScopeAdvisorySwitch" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.38" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="enableInteractionRelevanceAdvisorySwitch" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.39" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="disableInteractionRelevanceAdvisorySwitch" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.40" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="evokeCallback" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.41" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="evokeMultipleCallbacks" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.42" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="enableCallbacks" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.43" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *         &lt;element name="disableCallbacks" minOccurs="0">
 *           &lt;complexType>
 *             &lt;complexContent>
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *                 &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.44" />
 *                 &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
 *                 &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 &lt;anyAttribute namespace='##other'/>
 *               &lt;/restriction>
 *             &lt;/complexContent>
 *           &lt;/complexType>
 *         &lt;/element>
 *       &lt;/all>
 *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
 *       &lt;anyAttribute namespace='##other'/>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "serviceUtilizationType", propOrder = {

})
public class ServiceUtilizationType {

    protected ServiceUtilizationType.Connect connect;
    protected ServiceUtilizationType.Disconnect disconnect;
    protected ServiceUtilizationType.ConnectionLost connectionLost;
    protected ServiceUtilizationType.CreateFederationExecution createFederationExecution;
    protected ServiceUtilizationType.DestroyFederationExecution destroyFederationExecution;
    protected ServiceUtilizationType.ListFederationExecutions listFederationExecutions;
    protected ServiceUtilizationType.ReportFederationExecutions reportFederationExecutions;
    protected ServiceUtilizationType.JoinFederationExecution joinFederationExecution;
    protected ServiceUtilizationType.ResignFederationExecution resignFederationExecution;
    protected ServiceUtilizationType.RegisterFederationSynchronizationPoint registerFederationSynchronizationPoint;
    protected ServiceUtilizationType.ConfirmSynchronizationPointRegistration confirmSynchronizationPointRegistration;
    protected ServiceUtilizationType.AnnounceSynchronizationPoint announceSynchronizationPoint;
    protected ServiceUtilizationType.SynchronizationPointAchieved synchronizationPointAchieved;
    protected ServiceUtilizationType.FederationSynchronized federationSynchronized;
    protected ServiceUtilizationType.RequestFederationSave requestFederationSave;
    protected ServiceUtilizationType.InitiateFederateSave initiateFederateSave;
    protected ServiceUtilizationType.FederateSaveBegun federateSaveBegun;
    protected ServiceUtilizationType.FederateSaveComplete federateSaveComplete;
    protected ServiceUtilizationType.FederationSaved federationSaved;
    protected ServiceUtilizationType.AbortFederationSave abortFederationSave;
    protected ServiceUtilizationType.QueryFederationSaveStatus queryFederationSaveStatus;
    protected ServiceUtilizationType.FederationSaveStatusResponse federationSaveStatusResponse;
    protected ServiceUtilizationType.RequestFederationRestore requestFederationRestore;
    protected ServiceUtilizationType.ConfirmFederationRestorationRequest confirmFederationRestorationRequest;
    protected ServiceUtilizationType.FederationRestoreBegun federationRestoreBegun;
    protected ServiceUtilizationType.InitiateFederateRestore initiateFederateRestore;
    protected ServiceUtilizationType.FederateRestoreComplete federateRestoreComplete;
    protected ServiceUtilizationType.FederationRestored federationRestored;
    protected ServiceUtilizationType.AbortFederationRestore abortFederationRestore;
    protected ServiceUtilizationType.QueryFederationRestoreStatus queryFederationRestoreStatus;
    protected ServiceUtilizationType.FederationRestoreStatusResponse federationRestoreStatusResponse;
    protected ServiceUtilizationType.PublishObjectClassAttributes publishObjectClassAttributes;
    protected ServiceUtilizationType.UnpublishObjectClassAttributes unpublishObjectClassAttributes;
    protected ServiceUtilizationType.PublishInteractionClass publishInteractionClass;
    protected ServiceUtilizationType.UnpublishInteractionClass unpublishInteractionClass;
    protected ServiceUtilizationType.SubscribeObjectClassAttributes subscribeObjectClassAttributes;
    protected ServiceUtilizationType.UnsubscribeObjectClassAttributes unsubscribeObjectClassAttributes;
    protected ServiceUtilizationType.SubscribeInteractionClass subscribeInteractionClass;
    protected ServiceUtilizationType.UnsubscribeInteractionClass unsubscribeInteractionClass;
    protected ServiceUtilizationType.StartRegistrationForObjectClass startRegistrationForObjectClass;
    protected ServiceUtilizationType.StopRegistrationForObjectClass stopRegistrationForObjectClass;
    protected ServiceUtilizationType.TurnInteractionsOn turnInteractionsOn;
    protected ServiceUtilizationType.TurnInteractionsOff turnInteractionsOff;
    protected ServiceUtilizationType.ReserveObjectInstanceName reserveObjectInstanceName;
    protected ServiceUtilizationType.ObjectInstanceNameReserved objectInstanceNameReserved;
    protected ServiceUtilizationType.ReleaseObjectInstanceName releaseObjectInstanceName;
    protected ServiceUtilizationType.ReserveMultipleObjectInstanceNames reserveMultipleObjectInstanceNames;
    protected ServiceUtilizationType.MultipleObjectInstanceNamesReserved multipleObjectInstanceNamesReserved;
    protected ServiceUtilizationType.ReleaseMultipleObjectInstanceNames releaseMultipleObjectInstanceNames;
    protected ServiceUtilizationType.RegisterObjectInstance registerObjectInstance;
    protected ServiceUtilizationType.DiscoverObjectInstance discoverObjectInstance;
    protected ServiceUtilizationType.UpdateAttributeValues updateAttributeValues;
    protected ServiceUtilizationType.ReflectAttributeValues reflectAttributeValues;
    protected ServiceUtilizationType.SendInteraction sendInteraction;
    protected ServiceUtilizationType.ReceiveInteraction receiveInteraction;
    protected ServiceUtilizationType.DeleteObjectInstance deleteObjectInstance;
    protected ServiceUtilizationType.Removeobjectinstance removeobjectinstance;
    protected ServiceUtilizationType.LocalDeleteObjectInstance localDeleteObjectInstance;
    protected ServiceUtilizationType.AttributesInScope attributesInScope;
    protected ServiceUtilizationType.AttributesOutOfScope attributesOutOfScope;
    protected ServiceUtilizationType.RequestAttributeValueUpdate requestAttributeValueUpdate;
    protected ServiceUtilizationType.ProvideAttributeValueUpdate provideAttributeValueUpdate;
    protected ServiceUtilizationType.TurnUpdatesOnForObjectInstance turnUpdatesOnForObjectInstance;
    protected ServiceUtilizationType.TurnUpdatesOffForObjectInstance turnUpdatesOffForObjectInstance;
    protected ServiceUtilizationType.RequestAttributeTransportationTypeChange requestAttributeTransportationTypeChange;
    protected ServiceUtilizationType.ConfirmAttributeTransportationTypeChange confirmAttributeTransportationTypeChange;
    protected ServiceUtilizationType.QueryAttributeTransportationType queryAttributeTransportationType;
    protected ServiceUtilizationType.ReportAttributeTransportationType reportAttributeTransportationType;
    protected ServiceUtilizationType.RequestInteractionTransportationTypeChange requestInteractionTransportationTypeChange;
    protected ServiceUtilizationType.ConfirmInteractionTransportationTypeChange confirmInteractionTransportationTypeChange;
    protected ServiceUtilizationType.QueryInteractionTransportationType queryInteractionTransportationType;
    protected ServiceUtilizationType.ReportInteractionTransportationType reportInteractionTransportationType;
    protected ServiceUtilizationType.UnconditionalAttributeOwnershipDivestiture unconditionalAttributeOwnershipDivestiture;
    protected ServiceUtilizationType.NegotiatedAttributeOwnershipDivestiture negotiatedAttributeOwnershipDivestiture;
    protected ServiceUtilizationType.RequestAttributeOwnershipAssumption requestAttributeOwnershipAssumption;
    protected ServiceUtilizationType.RequestDivestitureConfirmation requestDivestitureConfirmation;
    protected ServiceUtilizationType.ConfirmDivestiture confirmDivestiture;
    protected ServiceUtilizationType.AttributeOwnershipAcquisitionNotification attributeOwnershipAcquisitionNotification;
    protected ServiceUtilizationType.AttributeOwnershipAcquisition attributeOwnershipAcquisition;
    protected ServiceUtilizationType.AttributeOwnershipAcquisitionIfAvailable attributeOwnershipAcquisitionIfAvailable;
    protected ServiceUtilizationType.AttributeOwnershipUnavailable attributeOwnershipUnavailable;
    protected ServiceUtilizationType.RequestAttributeOwnershipRelease requestAttributeOwnershipRelease;
    protected ServiceUtilizationType.AttributeOwnershipReleaseDenied attributeOwnershipReleaseDenied;
    protected ServiceUtilizationType.AttributeOwnershipDivestitureIfWanted attributeOwnershipDivestitureIfWanted;
    protected ServiceUtilizationType.CancelNegotiatedAttributeOwnershipDivestiture cancelNegotiatedAttributeOwnershipDivestiture;
    protected ServiceUtilizationType.CancelAttributeOwnershipAcquisition cancelAttributeOwnershipAcquisition;
    protected ServiceUtilizationType.ConfirmAttributeOwnershipAcquisitionCancellation confirmAttributeOwnershipAcquisitionCancellation;
    protected ServiceUtilizationType.QueryAttributeOwnership queryAttributeOwnership;
    protected ServiceUtilizationType.InformAttributeOwnership informAttributeOwnership;
    protected ServiceUtilizationType.IsAttributeOwnedByFederate isAttributeOwnedByFederate;
    protected ServiceUtilizationType.EnableTimeRegulation enableTimeRegulation;
    protected ServiceUtilizationType.TimeRegulationEnabled timeRegulationEnabled;
    protected ServiceUtilizationType.DisableTimeRegulation disableTimeRegulation;
    protected ServiceUtilizationType.EnableTimeConstrained enableTimeConstrained;
    protected ServiceUtilizationType.TimeConstrainedEnabled timeConstrainedEnabled;
    protected ServiceUtilizationType.DisableTimeConstrained disableTimeConstrained;
    protected ServiceUtilizationType.TimeAdvanceRequest timeAdvanceRequest;
    protected ServiceUtilizationType.TimeAdvanceRequestAvailable timeAdvanceRequestAvailable;
    protected ServiceUtilizationType.NextMessageRequest nextMessageRequest;
    protected ServiceUtilizationType.NextMessageRequestAvailable nextMessageRequestAvailable;
    protected ServiceUtilizationType.FlushQueueRequest flushQueueRequest;
    protected ServiceUtilizationType.TimeAdvanceGrant timeAdvanceGrant;
    protected ServiceUtilizationType.EnableAsynchronousDelivery enableAsynchronousDelivery;
    protected ServiceUtilizationType.DisableAsynchronousDelivery disableAsynchronousDelivery;
    protected ServiceUtilizationType.QueryGALT queryGALT;
    protected ServiceUtilizationType.QueryLogicalTime queryLogicalTime;
    protected ServiceUtilizationType.QueryLITS queryLITS;
    protected ServiceUtilizationType.ModifyLookahead modifyLookahead;
    protected ServiceUtilizationType.QueryLookahead queryLookahead;
    protected ServiceUtilizationType.Retract retract;
    protected ServiceUtilizationType.RequestRetraction requestRetraction;
    protected ServiceUtilizationType.ChangeAttributeOrderType changeAttributeOrderType;
    protected ServiceUtilizationType.ChangeInteractionOrderType changeInteractionOrderType;
    protected ServiceUtilizationType.CreateRegion createRegion;
    protected ServiceUtilizationType.CommitRegionModifications commitRegionModifications;
    protected ServiceUtilizationType.DeleteRegion deleteRegion;
    protected ServiceUtilizationType.RegisterObjectInstanceWithRegions registerObjectInstanceWithRegions;
    protected ServiceUtilizationType.AssociateRegionsForUpdates associateRegionsForUpdates;
    protected ServiceUtilizationType.UnassociateRegionsForUpdates unassociateRegionsForUpdates;
    protected ServiceUtilizationType.SubscribeObjectClassAttributesWithRegions subscribeObjectClassAttributesWithRegions;
    protected ServiceUtilizationType.UnsubscribeObjectClassAttributesWithRegions unsubscribeObjectClassAttributesWithRegions;
    protected ServiceUtilizationType.SubscribeInteractionClassWithRegions subscribeInteractionClassWithRegions;
    protected ServiceUtilizationType.UnsubscribeInteractionClassWithRegions unsubscribeInteractionClassWithRegions;
    protected ServiceUtilizationType.SendInteractionWithRegions sendInteractionWithRegions;
    protected ServiceUtilizationType.RequestAttributeValueUpdateWithRegions requestAttributeValueUpdateWithRegions;
    protected ServiceUtilizationType.GetAutomaticResignDirective getAutomaticResignDirective;
    protected ServiceUtilizationType.SetAutomaticResignDirective setAutomaticResignDirective;
    protected ServiceUtilizationType.GetFederateHandle getFederateHandle;
    protected ServiceUtilizationType.GetFederateName getFederateName;
    protected ServiceUtilizationType.GetObjectClassHandle getObjectClassHandle;
    protected ServiceUtilizationType.GetObjectClassName getObjectClassName;
    protected ServiceUtilizationType.GetKnownObjectClassHandle getKnownObjectClassHandle;
    protected ServiceUtilizationType.GetObjectInstanceHandle getObjectInstanceHandle;
    protected ServiceUtilizationType.GetObjectInstanceName getObjectInstanceName;
    protected ServiceUtilizationType.GetAttributeHandle getAttributeHandle;
    protected ServiceUtilizationType.GetAttributeName getAttributeName;
    protected ServiceUtilizationType.GetUpdateRateValue getUpdateRateValue;
    protected ServiceUtilizationType.GetUpdateRateValueForAttribute getUpdateRateValueForAttribute;
    protected ServiceUtilizationType.GetInteractionClassHandle getInteractionClassHandle;
    protected ServiceUtilizationType.GetInteractionClassName getInteractionClassName;
    protected ServiceUtilizationType.GetParameterHandle getParameterHandle;
    protected ServiceUtilizationType.GetParameterName getParameterName;
    protected ServiceUtilizationType.GetOrderType getOrderType;
    protected ServiceUtilizationType.GetOrderName getOrderName;
    protected ServiceUtilizationType.GetTransportationTypeHandle getTransportationTypeHandle;
    protected ServiceUtilizationType.GetTransportationTypeName getTransportationTypeName;
    protected ServiceUtilizationType.GetAvailableDimensionsForClassAttribute getAvailableDimensionsForClassAttribute;
    protected ServiceUtilizationType.GetAvailableDimensionsForInteractionClass getAvailableDimensionsForInteractionClass;
    protected ServiceUtilizationType.GetDimensionHandle getDimensionHandle;
    protected ServiceUtilizationType.GetDimensionName getDimensionName;
    protected ServiceUtilizationType.GetDimensionUpperBound getDimensionUpperBound;
    protected ServiceUtilizationType.GetDimensionHandleSet getDimensionHandleSet;
    protected ServiceUtilizationType.GetRangeBounds getRangeBounds;
    protected ServiceUtilizationType.SetRangeBounds setRangeBounds;
    protected ServiceUtilizationType.NormalizeFederateHandle normalizeFederateHandle;
    protected ServiceUtilizationType.NormalizeServiceGroup normalizeServiceGroup;
    protected ServiceUtilizationType.EnableObjectClassRelevanceAdvisorySwitch enableObjectClassRelevanceAdvisorySwitch;
    protected ServiceUtilizationType.DisableObjectClassRelevanceAdvisorySwitch disableObjectClassRelevanceAdvisorySwitch;
    protected ServiceUtilizationType.EnableAttributeRelevanceAdvisorySwitch enableAttributeRelevanceAdvisorySwitch;
    protected ServiceUtilizationType.DisableAttributeRelevanceAdvisorySwitch disableAttributeRelevanceAdvisorySwitch;
    protected ServiceUtilizationType.EnableAttributeScopeAdvisorySwitch enableAttributeScopeAdvisorySwitch;
    protected ServiceUtilizationType.DisableAttributeScopeAdvisorySwitch disableAttributeScopeAdvisorySwitch;
    protected ServiceUtilizationType.EnableInteractionRelevanceAdvisorySwitch enableInteractionRelevanceAdvisorySwitch;
    protected ServiceUtilizationType.DisableInteractionRelevanceAdvisorySwitch disableInteractionRelevanceAdvisorySwitch;
    protected ServiceUtilizationType.EvokeCallback evokeCallback;
    protected ServiceUtilizationType.EvokeMultipleCallbacks evokeMultipleCallbacks;
    protected ServiceUtilizationType.EnableCallbacks enableCallbacks;
    protected ServiceUtilizationType.DisableCallbacks disableCallbacks;
    @XmlAttribute(name = "notes")
    @XmlIDREF
    @XmlSchemaType(name = "IDREFS")
    protected List<Object> attrNotes;
    @XmlAttribute(name = "idtag")
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlID
    @XmlSchemaType(name = "ID")
    protected java.lang.String idtag;
    @XmlAnyAttribute
    private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

    /**
     * Obtient la valeur de la propriété connect.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.Connect }
     *     
     */
    public ServiceUtilizationType.Connect getConnect() {
        return connect;
    }

    /**
     * Définit la valeur de la propriété connect.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.Connect }
     *     
     */
    public void setConnect(ServiceUtilizationType.Connect value) {
        this.connect = value;
    }

    /**
     * Obtient la valeur de la propriété disconnect.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.Disconnect }
     *     
     */
    public ServiceUtilizationType.Disconnect getDisconnect() {
        return disconnect;
    }

    /**
     * Définit la valeur de la propriété disconnect.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.Disconnect }
     *     
     */
    public void setDisconnect(ServiceUtilizationType.Disconnect value) {
        this.disconnect = value;
    }

    /**
     * Obtient la valeur de la propriété connectionLost.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ConnectionLost }
     *     
     */
    public ServiceUtilizationType.ConnectionLost getConnectionLost() {
        return connectionLost;
    }

    /**
     * Définit la valeur de la propriété connectionLost.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ConnectionLost }
     *     
     */
    public void setConnectionLost(ServiceUtilizationType.ConnectionLost value) {
        this.connectionLost = value;
    }

    /**
     * Obtient la valeur de la propriété createFederationExecution.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.CreateFederationExecution }
     *     
     */
    public ServiceUtilizationType.CreateFederationExecution getCreateFederationExecution() {
        return createFederationExecution;
    }

    /**
     * Définit la valeur de la propriété createFederationExecution.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.CreateFederationExecution }
     *     
     */
    public void setCreateFederationExecution(ServiceUtilizationType.CreateFederationExecution value) {
        this.createFederationExecution = value;
    }

    /**
     * Obtient la valeur de la propriété destroyFederationExecution.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.DestroyFederationExecution }
     *     
     */
    public ServiceUtilizationType.DestroyFederationExecution getDestroyFederationExecution() {
        return destroyFederationExecution;
    }

    /**
     * Définit la valeur de la propriété destroyFederationExecution.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.DestroyFederationExecution }
     *     
     */
    public void setDestroyFederationExecution(ServiceUtilizationType.DestroyFederationExecution value) {
        this.destroyFederationExecution = value;
    }

    /**
     * Obtient la valeur de la propriété listFederationExecutions.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ListFederationExecutions }
     *     
     */
    public ServiceUtilizationType.ListFederationExecutions getListFederationExecutions() {
        return listFederationExecutions;
    }

    /**
     * Définit la valeur de la propriété listFederationExecutions.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ListFederationExecutions }
     *     
     */
    public void setListFederationExecutions(ServiceUtilizationType.ListFederationExecutions value) {
        this.listFederationExecutions = value;
    }

    /**
     * Obtient la valeur de la propriété reportFederationExecutions.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ReportFederationExecutions }
     *     
     */
    public ServiceUtilizationType.ReportFederationExecutions getReportFederationExecutions() {
        return reportFederationExecutions;
    }

    /**
     * Définit la valeur de la propriété reportFederationExecutions.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ReportFederationExecutions }
     *     
     */
    public void setReportFederationExecutions(ServiceUtilizationType.ReportFederationExecutions value) {
        this.reportFederationExecutions = value;
    }

    /**
     * Obtient la valeur de la propriété joinFederationExecution.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.JoinFederationExecution }
     *     
     */
    public ServiceUtilizationType.JoinFederationExecution getJoinFederationExecution() {
        return joinFederationExecution;
    }

    /**
     * Définit la valeur de la propriété joinFederationExecution.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.JoinFederationExecution }
     *     
     */
    public void setJoinFederationExecution(ServiceUtilizationType.JoinFederationExecution value) {
        this.joinFederationExecution = value;
    }

    /**
     * Obtient la valeur de la propriété resignFederationExecution.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ResignFederationExecution }
     *     
     */
    public ServiceUtilizationType.ResignFederationExecution getResignFederationExecution() {
        return resignFederationExecution;
    }

    /**
     * Définit la valeur de la propriété resignFederationExecution.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ResignFederationExecution }
     *     
     */
    public void setResignFederationExecution(ServiceUtilizationType.ResignFederationExecution value) {
        this.resignFederationExecution = value;
    }

    /**
     * Obtient la valeur de la propriété registerFederationSynchronizationPoint.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.RegisterFederationSynchronizationPoint }
     *     
     */
    public ServiceUtilizationType.RegisterFederationSynchronizationPoint getRegisterFederationSynchronizationPoint() {
        return registerFederationSynchronizationPoint;
    }

    /**
     * Définit la valeur de la propriété registerFederationSynchronizationPoint.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.RegisterFederationSynchronizationPoint }
     *     
     */
    public void setRegisterFederationSynchronizationPoint(ServiceUtilizationType.RegisterFederationSynchronizationPoint value) {
        this.registerFederationSynchronizationPoint = value;
    }

    /**
     * Obtient la valeur de la propriété confirmSynchronizationPointRegistration.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ConfirmSynchronizationPointRegistration }
     *     
     */
    public ServiceUtilizationType.ConfirmSynchronizationPointRegistration getConfirmSynchronizationPointRegistration() {
        return confirmSynchronizationPointRegistration;
    }

    /**
     * Définit la valeur de la propriété confirmSynchronizationPointRegistration.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ConfirmSynchronizationPointRegistration }
     *     
     */
    public void setConfirmSynchronizationPointRegistration(ServiceUtilizationType.ConfirmSynchronizationPointRegistration value) {
        this.confirmSynchronizationPointRegistration = value;
    }

    /**
     * Obtient la valeur de la propriété announceSynchronizationPoint.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.AnnounceSynchronizationPoint }
     *     
     */
    public ServiceUtilizationType.AnnounceSynchronizationPoint getAnnounceSynchronizationPoint() {
        return announceSynchronizationPoint;
    }

    /**
     * Définit la valeur de la propriété announceSynchronizationPoint.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.AnnounceSynchronizationPoint }
     *     
     */
    public void setAnnounceSynchronizationPoint(ServiceUtilizationType.AnnounceSynchronizationPoint value) {
        this.announceSynchronizationPoint = value;
    }

    /**
     * Obtient la valeur de la propriété synchronizationPointAchieved.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.SynchronizationPointAchieved }
     *     
     */
    public ServiceUtilizationType.SynchronizationPointAchieved getSynchronizationPointAchieved() {
        return synchronizationPointAchieved;
    }

    /**
     * Définit la valeur de la propriété synchronizationPointAchieved.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.SynchronizationPointAchieved }
     *     
     */
    public void setSynchronizationPointAchieved(ServiceUtilizationType.SynchronizationPointAchieved value) {
        this.synchronizationPointAchieved = value;
    }

    /**
     * Obtient la valeur de la propriété federationSynchronized.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.FederationSynchronized }
     *     
     */
    public ServiceUtilizationType.FederationSynchronized getFederationSynchronized() {
        return federationSynchronized;
    }

    /**
     * Définit la valeur de la propriété federationSynchronized.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.FederationSynchronized }
     *     
     */
    public void setFederationSynchronized(ServiceUtilizationType.FederationSynchronized value) {
        this.federationSynchronized = value;
    }

    /**
     * Obtient la valeur de la propriété requestFederationSave.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.RequestFederationSave }
     *     
     */
    public ServiceUtilizationType.RequestFederationSave getRequestFederationSave() {
        return requestFederationSave;
    }

    /**
     * Définit la valeur de la propriété requestFederationSave.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.RequestFederationSave }
     *     
     */
    public void setRequestFederationSave(ServiceUtilizationType.RequestFederationSave value) {
        this.requestFederationSave = value;
    }

    /**
     * Obtient la valeur de la propriété initiateFederateSave.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.InitiateFederateSave }
     *     
     */
    public ServiceUtilizationType.InitiateFederateSave getInitiateFederateSave() {
        return initiateFederateSave;
    }

    /**
     * Définit la valeur de la propriété initiateFederateSave.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.InitiateFederateSave }
     *     
     */
    public void setInitiateFederateSave(ServiceUtilizationType.InitiateFederateSave value) {
        this.initiateFederateSave = value;
    }

    /**
     * Obtient la valeur de la propriété federateSaveBegun.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.FederateSaveBegun }
     *     
     */
    public ServiceUtilizationType.FederateSaveBegun getFederateSaveBegun() {
        return federateSaveBegun;
    }

    /**
     * Définit la valeur de la propriété federateSaveBegun.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.FederateSaveBegun }
     *     
     */
    public void setFederateSaveBegun(ServiceUtilizationType.FederateSaveBegun value) {
        this.federateSaveBegun = value;
    }

    /**
     * Obtient la valeur de la propriété federateSaveComplete.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.FederateSaveComplete }
     *     
     */
    public ServiceUtilizationType.FederateSaveComplete getFederateSaveComplete() {
        return federateSaveComplete;
    }

    /**
     * Définit la valeur de la propriété federateSaveComplete.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.FederateSaveComplete }
     *     
     */
    public void setFederateSaveComplete(ServiceUtilizationType.FederateSaveComplete value) {
        this.federateSaveComplete = value;
    }

    /**
     * Obtient la valeur de la propriété federationSaved.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.FederationSaved }
     *     
     */
    public ServiceUtilizationType.FederationSaved getFederationSaved() {
        return federationSaved;
    }

    /**
     * Définit la valeur de la propriété federationSaved.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.FederationSaved }
     *     
     */
    public void setFederationSaved(ServiceUtilizationType.FederationSaved value) {
        this.federationSaved = value;
    }

    /**
     * Obtient la valeur de la propriété abortFederationSave.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.AbortFederationSave }
     *     
     */
    public ServiceUtilizationType.AbortFederationSave getAbortFederationSave() {
        return abortFederationSave;
    }

    /**
     * Définit la valeur de la propriété abortFederationSave.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.AbortFederationSave }
     *     
     */
    public void setAbortFederationSave(ServiceUtilizationType.AbortFederationSave value) {
        this.abortFederationSave = value;
    }

    /**
     * Obtient la valeur de la propriété queryFederationSaveStatus.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.QueryFederationSaveStatus }
     *     
     */
    public ServiceUtilizationType.QueryFederationSaveStatus getQueryFederationSaveStatus() {
        return queryFederationSaveStatus;
    }

    /**
     * Définit la valeur de la propriété queryFederationSaveStatus.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.QueryFederationSaveStatus }
     *     
     */
    public void setQueryFederationSaveStatus(ServiceUtilizationType.QueryFederationSaveStatus value) {
        this.queryFederationSaveStatus = value;
    }

    /**
     * Obtient la valeur de la propriété federationSaveStatusResponse.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.FederationSaveStatusResponse }
     *     
     */
    public ServiceUtilizationType.FederationSaveStatusResponse getFederationSaveStatusResponse() {
        return federationSaveStatusResponse;
    }

    /**
     * Définit la valeur de la propriété federationSaveStatusResponse.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.FederationSaveStatusResponse }
     *     
     */
    public void setFederationSaveStatusResponse(ServiceUtilizationType.FederationSaveStatusResponse value) {
        this.federationSaveStatusResponse = value;
    }

    /**
     * Obtient la valeur de la propriété requestFederationRestore.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.RequestFederationRestore }
     *     
     */
    public ServiceUtilizationType.RequestFederationRestore getRequestFederationRestore() {
        return requestFederationRestore;
    }

    /**
     * Définit la valeur de la propriété requestFederationRestore.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.RequestFederationRestore }
     *     
     */
    public void setRequestFederationRestore(ServiceUtilizationType.RequestFederationRestore value) {
        this.requestFederationRestore = value;
    }

    /**
     * Obtient la valeur de la propriété confirmFederationRestorationRequest.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ConfirmFederationRestorationRequest }
     *     
     */
    public ServiceUtilizationType.ConfirmFederationRestorationRequest getConfirmFederationRestorationRequest() {
        return confirmFederationRestorationRequest;
    }

    /**
     * Définit la valeur de la propriété confirmFederationRestorationRequest.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ConfirmFederationRestorationRequest }
     *     
     */
    public void setConfirmFederationRestorationRequest(ServiceUtilizationType.ConfirmFederationRestorationRequest value) {
        this.confirmFederationRestorationRequest = value;
    }

    /**
     * Obtient la valeur de la propriété federationRestoreBegun.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.FederationRestoreBegun }
     *     
     */
    public ServiceUtilizationType.FederationRestoreBegun getFederationRestoreBegun() {
        return federationRestoreBegun;
    }

    /**
     * Définit la valeur de la propriété federationRestoreBegun.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.FederationRestoreBegun }
     *     
     */
    public void setFederationRestoreBegun(ServiceUtilizationType.FederationRestoreBegun value) {
        this.federationRestoreBegun = value;
    }

    /**
     * Obtient la valeur de la propriété initiateFederateRestore.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.InitiateFederateRestore }
     *     
     */
    public ServiceUtilizationType.InitiateFederateRestore getInitiateFederateRestore() {
        return initiateFederateRestore;
    }

    /**
     * Définit la valeur de la propriété initiateFederateRestore.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.InitiateFederateRestore }
     *     
     */
    public void setInitiateFederateRestore(ServiceUtilizationType.InitiateFederateRestore value) {
        this.initiateFederateRestore = value;
    }

    /**
     * Obtient la valeur de la propriété federateRestoreComplete.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.FederateRestoreComplete }
     *     
     */
    public ServiceUtilizationType.FederateRestoreComplete getFederateRestoreComplete() {
        return federateRestoreComplete;
    }

    /**
     * Définit la valeur de la propriété federateRestoreComplete.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.FederateRestoreComplete }
     *     
     */
    public void setFederateRestoreComplete(ServiceUtilizationType.FederateRestoreComplete value) {
        this.federateRestoreComplete = value;
    }

    /**
     * Obtient la valeur de la propriété federationRestored.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.FederationRestored }
     *     
     */
    public ServiceUtilizationType.FederationRestored getFederationRestored() {
        return federationRestored;
    }

    /**
     * Définit la valeur de la propriété federationRestored.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.FederationRestored }
     *     
     */
    public void setFederationRestored(ServiceUtilizationType.FederationRestored value) {
        this.federationRestored = value;
    }

    /**
     * Obtient la valeur de la propriété abortFederationRestore.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.AbortFederationRestore }
     *     
     */
    public ServiceUtilizationType.AbortFederationRestore getAbortFederationRestore() {
        return abortFederationRestore;
    }

    /**
     * Définit la valeur de la propriété abortFederationRestore.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.AbortFederationRestore }
     *     
     */
    public void setAbortFederationRestore(ServiceUtilizationType.AbortFederationRestore value) {
        this.abortFederationRestore = value;
    }

    /**
     * Obtient la valeur de la propriété queryFederationRestoreStatus.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.QueryFederationRestoreStatus }
     *     
     */
    public ServiceUtilizationType.QueryFederationRestoreStatus getQueryFederationRestoreStatus() {
        return queryFederationRestoreStatus;
    }

    /**
     * Définit la valeur de la propriété queryFederationRestoreStatus.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.QueryFederationRestoreStatus }
     *     
     */
    public void setQueryFederationRestoreStatus(ServiceUtilizationType.QueryFederationRestoreStatus value) {
        this.queryFederationRestoreStatus = value;
    }

    /**
     * Obtient la valeur de la propriété federationRestoreStatusResponse.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.FederationRestoreStatusResponse }
     *     
     */
    public ServiceUtilizationType.FederationRestoreStatusResponse getFederationRestoreStatusResponse() {
        return federationRestoreStatusResponse;
    }

    /**
     * Définit la valeur de la propriété federationRestoreStatusResponse.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.FederationRestoreStatusResponse }
     *     
     */
    public void setFederationRestoreStatusResponse(ServiceUtilizationType.FederationRestoreStatusResponse value) {
        this.federationRestoreStatusResponse = value;
    }

    /**
     * Obtient la valeur de la propriété publishObjectClassAttributes.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.PublishObjectClassAttributes }
     *     
     */
    public ServiceUtilizationType.PublishObjectClassAttributes getPublishObjectClassAttributes() {
        return publishObjectClassAttributes;
    }

    /**
     * Définit la valeur de la propriété publishObjectClassAttributes.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.PublishObjectClassAttributes }
     *     
     */
    public void setPublishObjectClassAttributes(ServiceUtilizationType.PublishObjectClassAttributes value) {
        this.publishObjectClassAttributes = value;
    }

    /**
     * Obtient la valeur de la propriété unpublishObjectClassAttributes.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.UnpublishObjectClassAttributes }
     *     
     */
    public ServiceUtilizationType.UnpublishObjectClassAttributes getUnpublishObjectClassAttributes() {
        return unpublishObjectClassAttributes;
    }

    /**
     * Définit la valeur de la propriété unpublishObjectClassAttributes.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.UnpublishObjectClassAttributes }
     *     
     */
    public void setUnpublishObjectClassAttributes(ServiceUtilizationType.UnpublishObjectClassAttributes value) {
        this.unpublishObjectClassAttributes = value;
    }

    /**
     * Obtient la valeur de la propriété publishInteractionClass.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.PublishInteractionClass }
     *     
     */
    public ServiceUtilizationType.PublishInteractionClass getPublishInteractionClass() {
        return publishInteractionClass;
    }

    /**
     * Définit la valeur de la propriété publishInteractionClass.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.PublishInteractionClass }
     *     
     */
    public void setPublishInteractionClass(ServiceUtilizationType.PublishInteractionClass value) {
        this.publishInteractionClass = value;
    }

    /**
     * Obtient la valeur de la propriété unpublishInteractionClass.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.UnpublishInteractionClass }
     *     
     */
    public ServiceUtilizationType.UnpublishInteractionClass getUnpublishInteractionClass() {
        return unpublishInteractionClass;
    }

    /**
     * Définit la valeur de la propriété unpublishInteractionClass.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.UnpublishInteractionClass }
     *     
     */
    public void setUnpublishInteractionClass(ServiceUtilizationType.UnpublishInteractionClass value) {
        this.unpublishInteractionClass = value;
    }

    /**
     * Obtient la valeur de la propriété subscribeObjectClassAttributes.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.SubscribeObjectClassAttributes }
     *     
     */
    public ServiceUtilizationType.SubscribeObjectClassAttributes getSubscribeObjectClassAttributes() {
        return subscribeObjectClassAttributes;
    }

    /**
     * Définit la valeur de la propriété subscribeObjectClassAttributes.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.SubscribeObjectClassAttributes }
     *     
     */
    public void setSubscribeObjectClassAttributes(ServiceUtilizationType.SubscribeObjectClassAttributes value) {
        this.subscribeObjectClassAttributes = value;
    }

    /**
     * Obtient la valeur de la propriété unsubscribeObjectClassAttributes.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.UnsubscribeObjectClassAttributes }
     *     
     */
    public ServiceUtilizationType.UnsubscribeObjectClassAttributes getUnsubscribeObjectClassAttributes() {
        return unsubscribeObjectClassAttributes;
    }

    /**
     * Définit la valeur de la propriété unsubscribeObjectClassAttributes.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.UnsubscribeObjectClassAttributes }
     *     
     */
    public void setUnsubscribeObjectClassAttributes(ServiceUtilizationType.UnsubscribeObjectClassAttributes value) {
        this.unsubscribeObjectClassAttributes = value;
    }

    /**
     * Obtient la valeur de la propriété subscribeInteractionClass.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.SubscribeInteractionClass }
     *     
     */
    public ServiceUtilizationType.SubscribeInteractionClass getSubscribeInteractionClass() {
        return subscribeInteractionClass;
    }

    /**
     * Définit la valeur de la propriété subscribeInteractionClass.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.SubscribeInteractionClass }
     *     
     */
    public void setSubscribeInteractionClass(ServiceUtilizationType.SubscribeInteractionClass value) {
        this.subscribeInteractionClass = value;
    }

    /**
     * Obtient la valeur de la propriété unsubscribeInteractionClass.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.UnsubscribeInteractionClass }
     *     
     */
    public ServiceUtilizationType.UnsubscribeInteractionClass getUnsubscribeInteractionClass() {
        return unsubscribeInteractionClass;
    }

    /**
     * Définit la valeur de la propriété unsubscribeInteractionClass.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.UnsubscribeInteractionClass }
     *     
     */
    public void setUnsubscribeInteractionClass(ServiceUtilizationType.UnsubscribeInteractionClass value) {
        this.unsubscribeInteractionClass = value;
    }

    /**
     * Obtient la valeur de la propriété startRegistrationForObjectClass.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.StartRegistrationForObjectClass }
     *     
     */
    public ServiceUtilizationType.StartRegistrationForObjectClass getStartRegistrationForObjectClass() {
        return startRegistrationForObjectClass;
    }

    /**
     * Définit la valeur de la propriété startRegistrationForObjectClass.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.StartRegistrationForObjectClass }
     *     
     */
    public void setStartRegistrationForObjectClass(ServiceUtilizationType.StartRegistrationForObjectClass value) {
        this.startRegistrationForObjectClass = value;
    }

    /**
     * Obtient la valeur de la propriété stopRegistrationForObjectClass.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.StopRegistrationForObjectClass }
     *     
     */
    public ServiceUtilizationType.StopRegistrationForObjectClass getStopRegistrationForObjectClass() {
        return stopRegistrationForObjectClass;
    }

    /**
     * Définit la valeur de la propriété stopRegistrationForObjectClass.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.StopRegistrationForObjectClass }
     *     
     */
    public void setStopRegistrationForObjectClass(ServiceUtilizationType.StopRegistrationForObjectClass value) {
        this.stopRegistrationForObjectClass = value;
    }

    /**
     * Obtient la valeur de la propriété turnInteractionsOn.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.TurnInteractionsOn }
     *     
     */
    public ServiceUtilizationType.TurnInteractionsOn getTurnInteractionsOn() {
        return turnInteractionsOn;
    }

    /**
     * Définit la valeur de la propriété turnInteractionsOn.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.TurnInteractionsOn }
     *     
     */
    public void setTurnInteractionsOn(ServiceUtilizationType.TurnInteractionsOn value) {
        this.turnInteractionsOn = value;
    }

    /**
     * Obtient la valeur de la propriété turnInteractionsOff.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.TurnInteractionsOff }
     *     
     */
    public ServiceUtilizationType.TurnInteractionsOff getTurnInteractionsOff() {
        return turnInteractionsOff;
    }

    /**
     * Définit la valeur de la propriété turnInteractionsOff.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.TurnInteractionsOff }
     *     
     */
    public void setTurnInteractionsOff(ServiceUtilizationType.TurnInteractionsOff value) {
        this.turnInteractionsOff = value;
    }

    /**
     * Obtient la valeur de la propriété reserveObjectInstanceName.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ReserveObjectInstanceName }
     *     
     */
    public ServiceUtilizationType.ReserveObjectInstanceName getReserveObjectInstanceName() {
        return reserveObjectInstanceName;
    }

    /**
     * Définit la valeur de la propriété reserveObjectInstanceName.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ReserveObjectInstanceName }
     *     
     */
    public void setReserveObjectInstanceName(ServiceUtilizationType.ReserveObjectInstanceName value) {
        this.reserveObjectInstanceName = value;
    }

    /**
     * Obtient la valeur de la propriété objectInstanceNameReserved.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ObjectInstanceNameReserved }
     *     
     */
    public ServiceUtilizationType.ObjectInstanceNameReserved getObjectInstanceNameReserved() {
        return objectInstanceNameReserved;
    }

    /**
     * Définit la valeur de la propriété objectInstanceNameReserved.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ObjectInstanceNameReserved }
     *     
     */
    public void setObjectInstanceNameReserved(ServiceUtilizationType.ObjectInstanceNameReserved value) {
        this.objectInstanceNameReserved = value;
    }

    /**
     * Obtient la valeur de la propriété releaseObjectInstanceName.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ReleaseObjectInstanceName }
     *     
     */
    public ServiceUtilizationType.ReleaseObjectInstanceName getReleaseObjectInstanceName() {
        return releaseObjectInstanceName;
    }

    /**
     * Définit la valeur de la propriété releaseObjectInstanceName.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ReleaseObjectInstanceName }
     *     
     */
    public void setReleaseObjectInstanceName(ServiceUtilizationType.ReleaseObjectInstanceName value) {
        this.releaseObjectInstanceName = value;
    }

    /**
     * Obtient la valeur de la propriété reserveMultipleObjectInstanceNames.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ReserveMultipleObjectInstanceNames }
     *     
     */
    public ServiceUtilizationType.ReserveMultipleObjectInstanceNames getReserveMultipleObjectInstanceNames() {
        return reserveMultipleObjectInstanceNames;
    }

    /**
     * Définit la valeur de la propriété reserveMultipleObjectInstanceNames.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ReserveMultipleObjectInstanceNames }
     *     
     */
    public void setReserveMultipleObjectInstanceNames(ServiceUtilizationType.ReserveMultipleObjectInstanceNames value) {
        this.reserveMultipleObjectInstanceNames = value;
    }

    /**
     * Obtient la valeur de la propriété multipleObjectInstanceNamesReserved.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.MultipleObjectInstanceNamesReserved }
     *     
     */
    public ServiceUtilizationType.MultipleObjectInstanceNamesReserved getMultipleObjectInstanceNamesReserved() {
        return multipleObjectInstanceNamesReserved;
    }

    /**
     * Définit la valeur de la propriété multipleObjectInstanceNamesReserved.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.MultipleObjectInstanceNamesReserved }
     *     
     */
    public void setMultipleObjectInstanceNamesReserved(ServiceUtilizationType.MultipleObjectInstanceNamesReserved value) {
        this.multipleObjectInstanceNamesReserved = value;
    }

    /**
     * Obtient la valeur de la propriété releaseMultipleObjectInstanceNames.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ReleaseMultipleObjectInstanceNames }
     *     
     */
    public ServiceUtilizationType.ReleaseMultipleObjectInstanceNames getReleaseMultipleObjectInstanceNames() {
        return releaseMultipleObjectInstanceNames;
    }

    /**
     * Définit la valeur de la propriété releaseMultipleObjectInstanceNames.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ReleaseMultipleObjectInstanceNames }
     *     
     */
    public void setReleaseMultipleObjectInstanceNames(ServiceUtilizationType.ReleaseMultipleObjectInstanceNames value) {
        this.releaseMultipleObjectInstanceNames = value;
    }

    /**
     * Obtient la valeur de la propriété registerObjectInstance.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.RegisterObjectInstance }
     *     
     */
    public ServiceUtilizationType.RegisterObjectInstance getRegisterObjectInstance() {
        return registerObjectInstance;
    }

    /**
     * Définit la valeur de la propriété registerObjectInstance.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.RegisterObjectInstance }
     *     
     */
    public void setRegisterObjectInstance(ServiceUtilizationType.RegisterObjectInstance value) {
        this.registerObjectInstance = value;
    }

    /**
     * Obtient la valeur de la propriété discoverObjectInstance.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.DiscoverObjectInstance }
     *     
     */
    public ServiceUtilizationType.DiscoverObjectInstance getDiscoverObjectInstance() {
        return discoverObjectInstance;
    }

    /**
     * Définit la valeur de la propriété discoverObjectInstance.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.DiscoverObjectInstance }
     *     
     */
    public void setDiscoverObjectInstance(ServiceUtilizationType.DiscoverObjectInstance value) {
        this.discoverObjectInstance = value;
    }

    /**
     * Obtient la valeur de la propriété updateAttributeValues.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.UpdateAttributeValues }
     *     
     */
    public ServiceUtilizationType.UpdateAttributeValues getUpdateAttributeValues() {
        return updateAttributeValues;
    }

    /**
     * Définit la valeur de la propriété updateAttributeValues.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.UpdateAttributeValues }
     *     
     */
    public void setUpdateAttributeValues(ServiceUtilizationType.UpdateAttributeValues value) {
        this.updateAttributeValues = value;
    }

    /**
     * Obtient la valeur de la propriété reflectAttributeValues.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ReflectAttributeValues }
     *     
     */
    public ServiceUtilizationType.ReflectAttributeValues getReflectAttributeValues() {
        return reflectAttributeValues;
    }

    /**
     * Définit la valeur de la propriété reflectAttributeValues.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ReflectAttributeValues }
     *     
     */
    public void setReflectAttributeValues(ServiceUtilizationType.ReflectAttributeValues value) {
        this.reflectAttributeValues = value;
    }

    /**
     * Obtient la valeur de la propriété sendInteraction.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.SendInteraction }
     *     
     */
    public ServiceUtilizationType.SendInteraction getSendInteraction() {
        return sendInteraction;
    }

    /**
     * Définit la valeur de la propriété sendInteraction.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.SendInteraction }
     *     
     */
    public void setSendInteraction(ServiceUtilizationType.SendInteraction value) {
        this.sendInteraction = value;
    }

    /**
     * Obtient la valeur de la propriété receiveInteraction.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ReceiveInteraction }
     *     
     */
    public ServiceUtilizationType.ReceiveInteraction getReceiveInteraction() {
        return receiveInteraction;
    }

    /**
     * Définit la valeur de la propriété receiveInteraction.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ReceiveInteraction }
     *     
     */
    public void setReceiveInteraction(ServiceUtilizationType.ReceiveInteraction value) {
        this.receiveInteraction = value;
    }

    /**
     * Obtient la valeur de la propriété deleteObjectInstance.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.DeleteObjectInstance }
     *     
     */
    public ServiceUtilizationType.DeleteObjectInstance getDeleteObjectInstance() {
        return deleteObjectInstance;
    }

    /**
     * Définit la valeur de la propriété deleteObjectInstance.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.DeleteObjectInstance }
     *     
     */
    public void setDeleteObjectInstance(ServiceUtilizationType.DeleteObjectInstance value) {
        this.deleteObjectInstance = value;
    }

    /**
     * Obtient la valeur de la propriété removeobjectinstance.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.Removeobjectinstance }
     *     
     */
    public ServiceUtilizationType.Removeobjectinstance getRemoveobjectinstance() {
        return removeobjectinstance;
    }

    /**
     * Définit la valeur de la propriété removeobjectinstance.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.Removeobjectinstance }
     *     
     */
    public void setRemoveobjectinstance(ServiceUtilizationType.Removeobjectinstance value) {
        this.removeobjectinstance = value;
    }

    /**
     * Obtient la valeur de la propriété localDeleteObjectInstance.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.LocalDeleteObjectInstance }
     *     
     */
    public ServiceUtilizationType.LocalDeleteObjectInstance getLocalDeleteObjectInstance() {
        return localDeleteObjectInstance;
    }

    /**
     * Définit la valeur de la propriété localDeleteObjectInstance.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.LocalDeleteObjectInstance }
     *     
     */
    public void setLocalDeleteObjectInstance(ServiceUtilizationType.LocalDeleteObjectInstance value) {
        this.localDeleteObjectInstance = value;
    }

    /**
     * Obtient la valeur de la propriété attributesInScope.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.AttributesInScope }
     *     
     */
    public ServiceUtilizationType.AttributesInScope getAttributesInScope() {
        return attributesInScope;
    }

    /**
     * Définit la valeur de la propriété attributesInScope.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.AttributesInScope }
     *     
     */
    public void setAttributesInScope(ServiceUtilizationType.AttributesInScope value) {
        this.attributesInScope = value;
    }

    /**
     * Obtient la valeur de la propriété attributesOutOfScope.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.AttributesOutOfScope }
     *     
     */
    public ServiceUtilizationType.AttributesOutOfScope getAttributesOutOfScope() {
        return attributesOutOfScope;
    }

    /**
     * Définit la valeur de la propriété attributesOutOfScope.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.AttributesOutOfScope }
     *     
     */
    public void setAttributesOutOfScope(ServiceUtilizationType.AttributesOutOfScope value) {
        this.attributesOutOfScope = value;
    }

    /**
     * Obtient la valeur de la propriété requestAttributeValueUpdate.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.RequestAttributeValueUpdate }
     *     
     */
    public ServiceUtilizationType.RequestAttributeValueUpdate getRequestAttributeValueUpdate() {
        return requestAttributeValueUpdate;
    }

    /**
     * Définit la valeur de la propriété requestAttributeValueUpdate.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.RequestAttributeValueUpdate }
     *     
     */
    public void setRequestAttributeValueUpdate(ServiceUtilizationType.RequestAttributeValueUpdate value) {
        this.requestAttributeValueUpdate = value;
    }

    /**
     * Obtient la valeur de la propriété provideAttributeValueUpdate.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ProvideAttributeValueUpdate }
     *     
     */
    public ServiceUtilizationType.ProvideAttributeValueUpdate getProvideAttributeValueUpdate() {
        return provideAttributeValueUpdate;
    }

    /**
     * Définit la valeur de la propriété provideAttributeValueUpdate.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ProvideAttributeValueUpdate }
     *     
     */
    public void setProvideAttributeValueUpdate(ServiceUtilizationType.ProvideAttributeValueUpdate value) {
        this.provideAttributeValueUpdate = value;
    }

    /**
     * Obtient la valeur de la propriété turnUpdatesOnForObjectInstance.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.TurnUpdatesOnForObjectInstance }
     *     
     */
    public ServiceUtilizationType.TurnUpdatesOnForObjectInstance getTurnUpdatesOnForObjectInstance() {
        return turnUpdatesOnForObjectInstance;
    }

    /**
     * Définit la valeur de la propriété turnUpdatesOnForObjectInstance.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.TurnUpdatesOnForObjectInstance }
     *     
     */
    public void setTurnUpdatesOnForObjectInstance(ServiceUtilizationType.TurnUpdatesOnForObjectInstance value) {
        this.turnUpdatesOnForObjectInstance = value;
    }

    /**
     * Obtient la valeur de la propriété turnUpdatesOffForObjectInstance.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.TurnUpdatesOffForObjectInstance }
     *     
     */
    public ServiceUtilizationType.TurnUpdatesOffForObjectInstance getTurnUpdatesOffForObjectInstance() {
        return turnUpdatesOffForObjectInstance;
    }

    /**
     * Définit la valeur de la propriété turnUpdatesOffForObjectInstance.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.TurnUpdatesOffForObjectInstance }
     *     
     */
    public void setTurnUpdatesOffForObjectInstance(ServiceUtilizationType.TurnUpdatesOffForObjectInstance value) {
        this.turnUpdatesOffForObjectInstance = value;
    }

    /**
     * Obtient la valeur de la propriété requestAttributeTransportationTypeChange.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.RequestAttributeTransportationTypeChange }
     *     
     */
    public ServiceUtilizationType.RequestAttributeTransportationTypeChange getRequestAttributeTransportationTypeChange() {
        return requestAttributeTransportationTypeChange;
    }

    /**
     * Définit la valeur de la propriété requestAttributeTransportationTypeChange.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.RequestAttributeTransportationTypeChange }
     *     
     */
    public void setRequestAttributeTransportationTypeChange(ServiceUtilizationType.RequestAttributeTransportationTypeChange value) {
        this.requestAttributeTransportationTypeChange = value;
    }

    /**
     * Obtient la valeur de la propriété confirmAttributeTransportationTypeChange.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ConfirmAttributeTransportationTypeChange }
     *     
     */
    public ServiceUtilizationType.ConfirmAttributeTransportationTypeChange getConfirmAttributeTransportationTypeChange() {
        return confirmAttributeTransportationTypeChange;
    }

    /**
     * Définit la valeur de la propriété confirmAttributeTransportationTypeChange.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ConfirmAttributeTransportationTypeChange }
     *     
     */
    public void setConfirmAttributeTransportationTypeChange(ServiceUtilizationType.ConfirmAttributeTransportationTypeChange value) {
        this.confirmAttributeTransportationTypeChange = value;
    }

    /**
     * Obtient la valeur de la propriété queryAttributeTransportationType.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.QueryAttributeTransportationType }
     *     
     */
    public ServiceUtilizationType.QueryAttributeTransportationType getQueryAttributeTransportationType() {
        return queryAttributeTransportationType;
    }

    /**
     * Définit la valeur de la propriété queryAttributeTransportationType.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.QueryAttributeTransportationType }
     *     
     */
    public void setQueryAttributeTransportationType(ServiceUtilizationType.QueryAttributeTransportationType value) {
        this.queryAttributeTransportationType = value;
    }

    /**
     * Obtient la valeur de la propriété reportAttributeTransportationType.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ReportAttributeTransportationType }
     *     
     */
    public ServiceUtilizationType.ReportAttributeTransportationType getReportAttributeTransportationType() {
        return reportAttributeTransportationType;
    }

    /**
     * Définit la valeur de la propriété reportAttributeTransportationType.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ReportAttributeTransportationType }
     *     
     */
    public void setReportAttributeTransportationType(ServiceUtilizationType.ReportAttributeTransportationType value) {
        this.reportAttributeTransportationType = value;
    }

    /**
     * Obtient la valeur de la propriété requestInteractionTransportationTypeChange.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.RequestInteractionTransportationTypeChange }
     *     
     */
    public ServiceUtilizationType.RequestInteractionTransportationTypeChange getRequestInteractionTransportationTypeChange() {
        return requestInteractionTransportationTypeChange;
    }

    /**
     * Définit la valeur de la propriété requestInteractionTransportationTypeChange.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.RequestInteractionTransportationTypeChange }
     *     
     */
    public void setRequestInteractionTransportationTypeChange(ServiceUtilizationType.RequestInteractionTransportationTypeChange value) {
        this.requestInteractionTransportationTypeChange = value;
    }

    /**
     * Obtient la valeur de la propriété confirmInteractionTransportationTypeChange.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ConfirmInteractionTransportationTypeChange }
     *     
     */
    public ServiceUtilizationType.ConfirmInteractionTransportationTypeChange getConfirmInteractionTransportationTypeChange() {
        return confirmInteractionTransportationTypeChange;
    }

    /**
     * Définit la valeur de la propriété confirmInteractionTransportationTypeChange.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ConfirmInteractionTransportationTypeChange }
     *     
     */
    public void setConfirmInteractionTransportationTypeChange(ServiceUtilizationType.ConfirmInteractionTransportationTypeChange value) {
        this.confirmInteractionTransportationTypeChange = value;
    }

    /**
     * Obtient la valeur de la propriété queryInteractionTransportationType.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.QueryInteractionTransportationType }
     *     
     */
    public ServiceUtilizationType.QueryInteractionTransportationType getQueryInteractionTransportationType() {
        return queryInteractionTransportationType;
    }

    /**
     * Définit la valeur de la propriété queryInteractionTransportationType.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.QueryInteractionTransportationType }
     *     
     */
    public void setQueryInteractionTransportationType(ServiceUtilizationType.QueryInteractionTransportationType value) {
        this.queryInteractionTransportationType = value;
    }

    /**
     * Obtient la valeur de la propriété reportInteractionTransportationType.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ReportInteractionTransportationType }
     *     
     */
    public ServiceUtilizationType.ReportInteractionTransportationType getReportInteractionTransportationType() {
        return reportInteractionTransportationType;
    }

    /**
     * Définit la valeur de la propriété reportInteractionTransportationType.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ReportInteractionTransportationType }
     *     
     */
    public void setReportInteractionTransportationType(ServiceUtilizationType.ReportInteractionTransportationType value) {
        this.reportInteractionTransportationType = value;
    }

    /**
     * Obtient la valeur de la propriété unconditionalAttributeOwnershipDivestiture.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.UnconditionalAttributeOwnershipDivestiture }
     *     
     */
    public ServiceUtilizationType.UnconditionalAttributeOwnershipDivestiture getUnconditionalAttributeOwnershipDivestiture() {
        return unconditionalAttributeOwnershipDivestiture;
    }

    /**
     * Définit la valeur de la propriété unconditionalAttributeOwnershipDivestiture.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.UnconditionalAttributeOwnershipDivestiture }
     *     
     */
    public void setUnconditionalAttributeOwnershipDivestiture(ServiceUtilizationType.UnconditionalAttributeOwnershipDivestiture value) {
        this.unconditionalAttributeOwnershipDivestiture = value;
    }

    /**
     * Obtient la valeur de la propriété negotiatedAttributeOwnershipDivestiture.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.NegotiatedAttributeOwnershipDivestiture }
     *     
     */
    public ServiceUtilizationType.NegotiatedAttributeOwnershipDivestiture getNegotiatedAttributeOwnershipDivestiture() {
        return negotiatedAttributeOwnershipDivestiture;
    }

    /**
     * Définit la valeur de la propriété negotiatedAttributeOwnershipDivestiture.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.NegotiatedAttributeOwnershipDivestiture }
     *     
     */
    public void setNegotiatedAttributeOwnershipDivestiture(ServiceUtilizationType.NegotiatedAttributeOwnershipDivestiture value) {
        this.negotiatedAttributeOwnershipDivestiture = value;
    }

    /**
     * Obtient la valeur de la propriété requestAttributeOwnershipAssumption.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.RequestAttributeOwnershipAssumption }
     *     
     */
    public ServiceUtilizationType.RequestAttributeOwnershipAssumption getRequestAttributeOwnershipAssumption() {
        return requestAttributeOwnershipAssumption;
    }

    /**
     * Définit la valeur de la propriété requestAttributeOwnershipAssumption.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.RequestAttributeOwnershipAssumption }
     *     
     */
    public void setRequestAttributeOwnershipAssumption(ServiceUtilizationType.RequestAttributeOwnershipAssumption value) {
        this.requestAttributeOwnershipAssumption = value;
    }

    /**
     * Obtient la valeur de la propriété requestDivestitureConfirmation.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.RequestDivestitureConfirmation }
     *     
     */
    public ServiceUtilizationType.RequestDivestitureConfirmation getRequestDivestitureConfirmation() {
        return requestDivestitureConfirmation;
    }

    /**
     * Définit la valeur de la propriété requestDivestitureConfirmation.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.RequestDivestitureConfirmation }
     *     
     */
    public void setRequestDivestitureConfirmation(ServiceUtilizationType.RequestDivestitureConfirmation value) {
        this.requestDivestitureConfirmation = value;
    }

    /**
     * Obtient la valeur de la propriété confirmDivestiture.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ConfirmDivestiture }
     *     
     */
    public ServiceUtilizationType.ConfirmDivestiture getConfirmDivestiture() {
        return confirmDivestiture;
    }

    /**
     * Définit la valeur de la propriété confirmDivestiture.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ConfirmDivestiture }
     *     
     */
    public void setConfirmDivestiture(ServiceUtilizationType.ConfirmDivestiture value) {
        this.confirmDivestiture = value;
    }

    /**
     * Obtient la valeur de la propriété attributeOwnershipAcquisitionNotification.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.AttributeOwnershipAcquisitionNotification }
     *     
     */
    public ServiceUtilizationType.AttributeOwnershipAcquisitionNotification getAttributeOwnershipAcquisitionNotification() {
        return attributeOwnershipAcquisitionNotification;
    }

    /**
     * Définit la valeur de la propriété attributeOwnershipAcquisitionNotification.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.AttributeOwnershipAcquisitionNotification }
     *     
     */
    public void setAttributeOwnershipAcquisitionNotification(ServiceUtilizationType.AttributeOwnershipAcquisitionNotification value) {
        this.attributeOwnershipAcquisitionNotification = value;
    }

    /**
     * Obtient la valeur de la propriété attributeOwnershipAcquisition.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.AttributeOwnershipAcquisition }
     *     
     */
    public ServiceUtilizationType.AttributeOwnershipAcquisition getAttributeOwnershipAcquisition() {
        return attributeOwnershipAcquisition;
    }

    /**
     * Définit la valeur de la propriété attributeOwnershipAcquisition.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.AttributeOwnershipAcquisition }
     *     
     */
    public void setAttributeOwnershipAcquisition(ServiceUtilizationType.AttributeOwnershipAcquisition value) {
        this.attributeOwnershipAcquisition = value;
    }

    /**
     * Obtient la valeur de la propriété attributeOwnershipAcquisitionIfAvailable.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.AttributeOwnershipAcquisitionIfAvailable }
     *     
     */
    public ServiceUtilizationType.AttributeOwnershipAcquisitionIfAvailable getAttributeOwnershipAcquisitionIfAvailable() {
        return attributeOwnershipAcquisitionIfAvailable;
    }

    /**
     * Définit la valeur de la propriété attributeOwnershipAcquisitionIfAvailable.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.AttributeOwnershipAcquisitionIfAvailable }
     *     
     */
    public void setAttributeOwnershipAcquisitionIfAvailable(ServiceUtilizationType.AttributeOwnershipAcquisitionIfAvailable value) {
        this.attributeOwnershipAcquisitionIfAvailable = value;
    }

    /**
     * Obtient la valeur de la propriété attributeOwnershipUnavailable.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.AttributeOwnershipUnavailable }
     *     
     */
    public ServiceUtilizationType.AttributeOwnershipUnavailable getAttributeOwnershipUnavailable() {
        return attributeOwnershipUnavailable;
    }

    /**
     * Définit la valeur de la propriété attributeOwnershipUnavailable.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.AttributeOwnershipUnavailable }
     *     
     */
    public void setAttributeOwnershipUnavailable(ServiceUtilizationType.AttributeOwnershipUnavailable value) {
        this.attributeOwnershipUnavailable = value;
    }

    /**
     * Obtient la valeur de la propriété requestAttributeOwnershipRelease.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.RequestAttributeOwnershipRelease }
     *     
     */
    public ServiceUtilizationType.RequestAttributeOwnershipRelease getRequestAttributeOwnershipRelease() {
        return requestAttributeOwnershipRelease;
    }

    /**
     * Définit la valeur de la propriété requestAttributeOwnershipRelease.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.RequestAttributeOwnershipRelease }
     *     
     */
    public void setRequestAttributeOwnershipRelease(ServiceUtilizationType.RequestAttributeOwnershipRelease value) {
        this.requestAttributeOwnershipRelease = value;
    }

    /**
     * Obtient la valeur de la propriété attributeOwnershipReleaseDenied.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.AttributeOwnershipReleaseDenied }
     *     
     */
    public ServiceUtilizationType.AttributeOwnershipReleaseDenied getAttributeOwnershipReleaseDenied() {
        return attributeOwnershipReleaseDenied;
    }

    /**
     * Définit la valeur de la propriété attributeOwnershipReleaseDenied.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.AttributeOwnershipReleaseDenied }
     *     
     */
    public void setAttributeOwnershipReleaseDenied(ServiceUtilizationType.AttributeOwnershipReleaseDenied value) {
        this.attributeOwnershipReleaseDenied = value;
    }

    /**
     * Obtient la valeur de la propriété attributeOwnershipDivestitureIfWanted.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.AttributeOwnershipDivestitureIfWanted }
     *     
     */
    public ServiceUtilizationType.AttributeOwnershipDivestitureIfWanted getAttributeOwnershipDivestitureIfWanted() {
        return attributeOwnershipDivestitureIfWanted;
    }

    /**
     * Définit la valeur de la propriété attributeOwnershipDivestitureIfWanted.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.AttributeOwnershipDivestitureIfWanted }
     *     
     */
    public void setAttributeOwnershipDivestitureIfWanted(ServiceUtilizationType.AttributeOwnershipDivestitureIfWanted value) {
        this.attributeOwnershipDivestitureIfWanted = value;
    }

    /**
     * Obtient la valeur de la propriété cancelNegotiatedAttributeOwnershipDivestiture.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.CancelNegotiatedAttributeOwnershipDivestiture }
     *     
     */
    public ServiceUtilizationType.CancelNegotiatedAttributeOwnershipDivestiture getCancelNegotiatedAttributeOwnershipDivestiture() {
        return cancelNegotiatedAttributeOwnershipDivestiture;
    }

    /**
     * Définit la valeur de la propriété cancelNegotiatedAttributeOwnershipDivestiture.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.CancelNegotiatedAttributeOwnershipDivestiture }
     *     
     */
    public void setCancelNegotiatedAttributeOwnershipDivestiture(ServiceUtilizationType.CancelNegotiatedAttributeOwnershipDivestiture value) {
        this.cancelNegotiatedAttributeOwnershipDivestiture = value;
    }

    /**
     * Obtient la valeur de la propriété cancelAttributeOwnershipAcquisition.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.CancelAttributeOwnershipAcquisition }
     *     
     */
    public ServiceUtilizationType.CancelAttributeOwnershipAcquisition getCancelAttributeOwnershipAcquisition() {
        return cancelAttributeOwnershipAcquisition;
    }

    /**
     * Définit la valeur de la propriété cancelAttributeOwnershipAcquisition.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.CancelAttributeOwnershipAcquisition }
     *     
     */
    public void setCancelAttributeOwnershipAcquisition(ServiceUtilizationType.CancelAttributeOwnershipAcquisition value) {
        this.cancelAttributeOwnershipAcquisition = value;
    }

    /**
     * Obtient la valeur de la propriété confirmAttributeOwnershipAcquisitionCancellation.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ConfirmAttributeOwnershipAcquisitionCancellation }
     *     
     */
    public ServiceUtilizationType.ConfirmAttributeOwnershipAcquisitionCancellation getConfirmAttributeOwnershipAcquisitionCancellation() {
        return confirmAttributeOwnershipAcquisitionCancellation;
    }

    /**
     * Définit la valeur de la propriété confirmAttributeOwnershipAcquisitionCancellation.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ConfirmAttributeOwnershipAcquisitionCancellation }
     *     
     */
    public void setConfirmAttributeOwnershipAcquisitionCancellation(ServiceUtilizationType.ConfirmAttributeOwnershipAcquisitionCancellation value) {
        this.confirmAttributeOwnershipAcquisitionCancellation = value;
    }

    /**
     * Obtient la valeur de la propriété queryAttributeOwnership.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.QueryAttributeOwnership }
     *     
     */
    public ServiceUtilizationType.QueryAttributeOwnership getQueryAttributeOwnership() {
        return queryAttributeOwnership;
    }

    /**
     * Définit la valeur de la propriété queryAttributeOwnership.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.QueryAttributeOwnership }
     *     
     */
    public void setQueryAttributeOwnership(ServiceUtilizationType.QueryAttributeOwnership value) {
        this.queryAttributeOwnership = value;
    }

    /**
     * Obtient la valeur de la propriété informAttributeOwnership.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.InformAttributeOwnership }
     *     
     */
    public ServiceUtilizationType.InformAttributeOwnership getInformAttributeOwnership() {
        return informAttributeOwnership;
    }

    /**
     * Définit la valeur de la propriété informAttributeOwnership.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.InformAttributeOwnership }
     *     
     */
    public void setInformAttributeOwnership(ServiceUtilizationType.InformAttributeOwnership value) {
        this.informAttributeOwnership = value;
    }

    /**
     * Obtient la valeur de la propriété isAttributeOwnedByFederate.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.IsAttributeOwnedByFederate }
     *     
     */
    public ServiceUtilizationType.IsAttributeOwnedByFederate getIsAttributeOwnedByFederate() {
        return isAttributeOwnedByFederate;
    }

    /**
     * Définit la valeur de la propriété isAttributeOwnedByFederate.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.IsAttributeOwnedByFederate }
     *     
     */
    public void setIsAttributeOwnedByFederate(ServiceUtilizationType.IsAttributeOwnedByFederate value) {
        this.isAttributeOwnedByFederate = value;
    }

    /**
     * Obtient la valeur de la propriété enableTimeRegulation.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.EnableTimeRegulation }
     *     
     */
    public ServiceUtilizationType.EnableTimeRegulation getEnableTimeRegulation() {
        return enableTimeRegulation;
    }

    /**
     * Définit la valeur de la propriété enableTimeRegulation.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.EnableTimeRegulation }
     *     
     */
    public void setEnableTimeRegulation(ServiceUtilizationType.EnableTimeRegulation value) {
        this.enableTimeRegulation = value;
    }

    /**
     * Obtient la valeur de la propriété timeRegulationEnabled.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.TimeRegulationEnabled }
     *     
     */
    public ServiceUtilizationType.TimeRegulationEnabled getTimeRegulationEnabled() {
        return timeRegulationEnabled;
    }

    /**
     * Définit la valeur de la propriété timeRegulationEnabled.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.TimeRegulationEnabled }
     *     
     */
    public void setTimeRegulationEnabled(ServiceUtilizationType.TimeRegulationEnabled value) {
        this.timeRegulationEnabled = value;
    }

    /**
     * Obtient la valeur de la propriété disableTimeRegulation.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.DisableTimeRegulation }
     *     
     */
    public ServiceUtilizationType.DisableTimeRegulation getDisableTimeRegulation() {
        return disableTimeRegulation;
    }

    /**
     * Définit la valeur de la propriété disableTimeRegulation.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.DisableTimeRegulation }
     *     
     */
    public void setDisableTimeRegulation(ServiceUtilizationType.DisableTimeRegulation value) {
        this.disableTimeRegulation = value;
    }

    /**
     * Obtient la valeur de la propriété enableTimeConstrained.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.EnableTimeConstrained }
     *     
     */
    public ServiceUtilizationType.EnableTimeConstrained getEnableTimeConstrained() {
        return enableTimeConstrained;
    }

    /**
     * Définit la valeur de la propriété enableTimeConstrained.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.EnableTimeConstrained }
     *     
     */
    public void setEnableTimeConstrained(ServiceUtilizationType.EnableTimeConstrained value) {
        this.enableTimeConstrained = value;
    }

    /**
     * Obtient la valeur de la propriété timeConstrainedEnabled.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.TimeConstrainedEnabled }
     *     
     */
    public ServiceUtilizationType.TimeConstrainedEnabled getTimeConstrainedEnabled() {
        return timeConstrainedEnabled;
    }

    /**
     * Définit la valeur de la propriété timeConstrainedEnabled.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.TimeConstrainedEnabled }
     *     
     */
    public void setTimeConstrainedEnabled(ServiceUtilizationType.TimeConstrainedEnabled value) {
        this.timeConstrainedEnabled = value;
    }

    /**
     * Obtient la valeur de la propriété disableTimeConstrained.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.DisableTimeConstrained }
     *     
     */
    public ServiceUtilizationType.DisableTimeConstrained getDisableTimeConstrained() {
        return disableTimeConstrained;
    }

    /**
     * Définit la valeur de la propriété disableTimeConstrained.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.DisableTimeConstrained }
     *     
     */
    public void setDisableTimeConstrained(ServiceUtilizationType.DisableTimeConstrained value) {
        this.disableTimeConstrained = value;
    }

    /**
     * Obtient la valeur de la propriété timeAdvanceRequest.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.TimeAdvanceRequest }
     *     
     */
    public ServiceUtilizationType.TimeAdvanceRequest getTimeAdvanceRequest() {
        return timeAdvanceRequest;
    }

    /**
     * Définit la valeur de la propriété timeAdvanceRequest.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.TimeAdvanceRequest }
     *     
     */
    public void setTimeAdvanceRequest(ServiceUtilizationType.TimeAdvanceRequest value) {
        this.timeAdvanceRequest = value;
    }

    /**
     * Obtient la valeur de la propriété timeAdvanceRequestAvailable.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.TimeAdvanceRequestAvailable }
     *     
     */
    public ServiceUtilizationType.TimeAdvanceRequestAvailable getTimeAdvanceRequestAvailable() {
        return timeAdvanceRequestAvailable;
    }

    /**
     * Définit la valeur de la propriété timeAdvanceRequestAvailable.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.TimeAdvanceRequestAvailable }
     *     
     */
    public void setTimeAdvanceRequestAvailable(ServiceUtilizationType.TimeAdvanceRequestAvailable value) {
        this.timeAdvanceRequestAvailable = value;
    }

    /**
     * Obtient la valeur de la propriété nextMessageRequest.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.NextMessageRequest }
     *     
     */
    public ServiceUtilizationType.NextMessageRequest getNextMessageRequest() {
        return nextMessageRequest;
    }

    /**
     * Définit la valeur de la propriété nextMessageRequest.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.NextMessageRequest }
     *     
     */
    public void setNextMessageRequest(ServiceUtilizationType.NextMessageRequest value) {
        this.nextMessageRequest = value;
    }

    /**
     * Obtient la valeur de la propriété nextMessageRequestAvailable.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.NextMessageRequestAvailable }
     *     
     */
    public ServiceUtilizationType.NextMessageRequestAvailable getNextMessageRequestAvailable() {
        return nextMessageRequestAvailable;
    }

    /**
     * Définit la valeur de la propriété nextMessageRequestAvailable.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.NextMessageRequestAvailable }
     *     
     */
    public void setNextMessageRequestAvailable(ServiceUtilizationType.NextMessageRequestAvailable value) {
        this.nextMessageRequestAvailable = value;
    }

    /**
     * Obtient la valeur de la propriété flushQueueRequest.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.FlushQueueRequest }
     *     
     */
    public ServiceUtilizationType.FlushQueueRequest getFlushQueueRequest() {
        return flushQueueRequest;
    }

    /**
     * Définit la valeur de la propriété flushQueueRequest.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.FlushQueueRequest }
     *     
     */
    public void setFlushQueueRequest(ServiceUtilizationType.FlushQueueRequest value) {
        this.flushQueueRequest = value;
    }

    /**
     * Obtient la valeur de la propriété timeAdvanceGrant.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.TimeAdvanceGrant }
     *     
     */
    public ServiceUtilizationType.TimeAdvanceGrant getTimeAdvanceGrant() {
        return timeAdvanceGrant;
    }

    /**
     * Définit la valeur de la propriété timeAdvanceGrant.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.TimeAdvanceGrant }
     *     
     */
    public void setTimeAdvanceGrant(ServiceUtilizationType.TimeAdvanceGrant value) {
        this.timeAdvanceGrant = value;
    }

    /**
     * Obtient la valeur de la propriété enableAsynchronousDelivery.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.EnableAsynchronousDelivery }
     *     
     */
    public ServiceUtilizationType.EnableAsynchronousDelivery getEnableAsynchronousDelivery() {
        return enableAsynchronousDelivery;
    }

    /**
     * Définit la valeur de la propriété enableAsynchronousDelivery.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.EnableAsynchronousDelivery }
     *     
     */
    public void setEnableAsynchronousDelivery(ServiceUtilizationType.EnableAsynchronousDelivery value) {
        this.enableAsynchronousDelivery = value;
    }

    /**
     * Obtient la valeur de la propriété disableAsynchronousDelivery.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.DisableAsynchronousDelivery }
     *     
     */
    public ServiceUtilizationType.DisableAsynchronousDelivery getDisableAsynchronousDelivery() {
        return disableAsynchronousDelivery;
    }

    /**
     * Définit la valeur de la propriété disableAsynchronousDelivery.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.DisableAsynchronousDelivery }
     *     
     */
    public void setDisableAsynchronousDelivery(ServiceUtilizationType.DisableAsynchronousDelivery value) {
        this.disableAsynchronousDelivery = value;
    }

    /**
     * Obtient la valeur de la propriété queryGALT.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.QueryGALT }
     *     
     */
    public ServiceUtilizationType.QueryGALT getQueryGALT() {
        return queryGALT;
    }

    /**
     * Définit la valeur de la propriété queryGALT.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.QueryGALT }
     *     
     */
    public void setQueryGALT(ServiceUtilizationType.QueryGALT value) {
        this.queryGALT = value;
    }

    /**
     * Obtient la valeur de la propriété queryLogicalTime.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.QueryLogicalTime }
     *     
     */
    public ServiceUtilizationType.QueryLogicalTime getQueryLogicalTime() {
        return queryLogicalTime;
    }

    /**
     * Définit la valeur de la propriété queryLogicalTime.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.QueryLogicalTime }
     *     
     */
    public void setQueryLogicalTime(ServiceUtilizationType.QueryLogicalTime value) {
        this.queryLogicalTime = value;
    }

    /**
     * Obtient la valeur de la propriété queryLITS.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.QueryLITS }
     *     
     */
    public ServiceUtilizationType.QueryLITS getQueryLITS() {
        return queryLITS;
    }

    /**
     * Définit la valeur de la propriété queryLITS.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.QueryLITS }
     *     
     */
    public void setQueryLITS(ServiceUtilizationType.QueryLITS value) {
        this.queryLITS = value;
    }

    /**
     * Obtient la valeur de la propriété modifyLookahead.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ModifyLookahead }
     *     
     */
    public ServiceUtilizationType.ModifyLookahead getModifyLookahead() {
        return modifyLookahead;
    }

    /**
     * Définit la valeur de la propriété modifyLookahead.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ModifyLookahead }
     *     
     */
    public void setModifyLookahead(ServiceUtilizationType.ModifyLookahead value) {
        this.modifyLookahead = value;
    }

    /**
     * Obtient la valeur de la propriété queryLookahead.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.QueryLookahead }
     *     
     */
    public ServiceUtilizationType.QueryLookahead getQueryLookahead() {
        return queryLookahead;
    }

    /**
     * Définit la valeur de la propriété queryLookahead.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.QueryLookahead }
     *     
     */
    public void setQueryLookahead(ServiceUtilizationType.QueryLookahead value) {
        this.queryLookahead = value;
    }

    /**
     * Obtient la valeur de la propriété retract.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.Retract }
     *     
     */
    public ServiceUtilizationType.Retract getRetract() {
        return retract;
    }

    /**
     * Définit la valeur de la propriété retract.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.Retract }
     *     
     */
    public void setRetract(ServiceUtilizationType.Retract value) {
        this.retract = value;
    }

    /**
     * Obtient la valeur de la propriété requestRetraction.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.RequestRetraction }
     *     
     */
    public ServiceUtilizationType.RequestRetraction getRequestRetraction() {
        return requestRetraction;
    }

    /**
     * Définit la valeur de la propriété requestRetraction.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.RequestRetraction }
     *     
     */
    public void setRequestRetraction(ServiceUtilizationType.RequestRetraction value) {
        this.requestRetraction = value;
    }

    /**
     * Obtient la valeur de la propriété changeAttributeOrderType.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ChangeAttributeOrderType }
     *     
     */
    public ServiceUtilizationType.ChangeAttributeOrderType getChangeAttributeOrderType() {
        return changeAttributeOrderType;
    }

    /**
     * Définit la valeur de la propriété changeAttributeOrderType.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ChangeAttributeOrderType }
     *     
     */
    public void setChangeAttributeOrderType(ServiceUtilizationType.ChangeAttributeOrderType value) {
        this.changeAttributeOrderType = value;
    }

    /**
     * Obtient la valeur de la propriété changeInteractionOrderType.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.ChangeInteractionOrderType }
     *     
     */
    public ServiceUtilizationType.ChangeInteractionOrderType getChangeInteractionOrderType() {
        return changeInteractionOrderType;
    }

    /**
     * Définit la valeur de la propriété changeInteractionOrderType.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.ChangeInteractionOrderType }
     *     
     */
    public void setChangeInteractionOrderType(ServiceUtilizationType.ChangeInteractionOrderType value) {
        this.changeInteractionOrderType = value;
    }

    /**
     * Obtient la valeur de la propriété createRegion.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.CreateRegion }
     *     
     */
    public ServiceUtilizationType.CreateRegion getCreateRegion() {
        return createRegion;
    }

    /**
     * Définit la valeur de la propriété createRegion.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.CreateRegion }
     *     
     */
    public void setCreateRegion(ServiceUtilizationType.CreateRegion value) {
        this.createRegion = value;
    }

    /**
     * Obtient la valeur de la propriété commitRegionModifications.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.CommitRegionModifications }
     *     
     */
    public ServiceUtilizationType.CommitRegionModifications getCommitRegionModifications() {
        return commitRegionModifications;
    }

    /**
     * Définit la valeur de la propriété commitRegionModifications.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.CommitRegionModifications }
     *     
     */
    public void setCommitRegionModifications(ServiceUtilizationType.CommitRegionModifications value) {
        this.commitRegionModifications = value;
    }

    /**
     * Obtient la valeur de la propriété deleteRegion.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.DeleteRegion }
     *     
     */
    public ServiceUtilizationType.DeleteRegion getDeleteRegion() {
        return deleteRegion;
    }

    /**
     * Définit la valeur de la propriété deleteRegion.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.DeleteRegion }
     *     
     */
    public void setDeleteRegion(ServiceUtilizationType.DeleteRegion value) {
        this.deleteRegion = value;
    }

    /**
     * Obtient la valeur de la propriété registerObjectInstanceWithRegions.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.RegisterObjectInstanceWithRegions }
     *     
     */
    public ServiceUtilizationType.RegisterObjectInstanceWithRegions getRegisterObjectInstanceWithRegions() {
        return registerObjectInstanceWithRegions;
    }

    /**
     * Définit la valeur de la propriété registerObjectInstanceWithRegions.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.RegisterObjectInstanceWithRegions }
     *     
     */
    public void setRegisterObjectInstanceWithRegions(ServiceUtilizationType.RegisterObjectInstanceWithRegions value) {
        this.registerObjectInstanceWithRegions = value;
    }

    /**
     * Obtient la valeur de la propriété associateRegionsForUpdates.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.AssociateRegionsForUpdates }
     *     
     */
    public ServiceUtilizationType.AssociateRegionsForUpdates getAssociateRegionsForUpdates() {
        return associateRegionsForUpdates;
    }

    /**
     * Définit la valeur de la propriété associateRegionsForUpdates.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.AssociateRegionsForUpdates }
     *     
     */
    public void setAssociateRegionsForUpdates(ServiceUtilizationType.AssociateRegionsForUpdates value) {
        this.associateRegionsForUpdates = value;
    }

    /**
     * Obtient la valeur de la propriété unassociateRegionsForUpdates.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.UnassociateRegionsForUpdates }
     *     
     */
    public ServiceUtilizationType.UnassociateRegionsForUpdates getUnassociateRegionsForUpdates() {
        return unassociateRegionsForUpdates;
    }

    /**
     * Définit la valeur de la propriété unassociateRegionsForUpdates.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.UnassociateRegionsForUpdates }
     *     
     */
    public void setUnassociateRegionsForUpdates(ServiceUtilizationType.UnassociateRegionsForUpdates value) {
        this.unassociateRegionsForUpdates = value;
    }

    /**
     * Obtient la valeur de la propriété subscribeObjectClassAttributesWithRegions.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.SubscribeObjectClassAttributesWithRegions }
     *     
     */
    public ServiceUtilizationType.SubscribeObjectClassAttributesWithRegions getSubscribeObjectClassAttributesWithRegions() {
        return subscribeObjectClassAttributesWithRegions;
    }

    /**
     * Définit la valeur de la propriété subscribeObjectClassAttributesWithRegions.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.SubscribeObjectClassAttributesWithRegions }
     *     
     */
    public void setSubscribeObjectClassAttributesWithRegions(ServiceUtilizationType.SubscribeObjectClassAttributesWithRegions value) {
        this.subscribeObjectClassAttributesWithRegions = value;
    }

    /**
     * Obtient la valeur de la propriété unsubscribeObjectClassAttributesWithRegions.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.UnsubscribeObjectClassAttributesWithRegions }
     *     
     */
    public ServiceUtilizationType.UnsubscribeObjectClassAttributesWithRegions getUnsubscribeObjectClassAttributesWithRegions() {
        return unsubscribeObjectClassAttributesWithRegions;
    }

    /**
     * Définit la valeur de la propriété unsubscribeObjectClassAttributesWithRegions.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.UnsubscribeObjectClassAttributesWithRegions }
     *     
     */
    public void setUnsubscribeObjectClassAttributesWithRegions(ServiceUtilizationType.UnsubscribeObjectClassAttributesWithRegions value) {
        this.unsubscribeObjectClassAttributesWithRegions = value;
    }

    /**
     * Obtient la valeur de la propriété subscribeInteractionClassWithRegions.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.SubscribeInteractionClassWithRegions }
     *     
     */
    public ServiceUtilizationType.SubscribeInteractionClassWithRegions getSubscribeInteractionClassWithRegions() {
        return subscribeInteractionClassWithRegions;
    }

    /**
     * Définit la valeur de la propriété subscribeInteractionClassWithRegions.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.SubscribeInteractionClassWithRegions }
     *     
     */
    public void setSubscribeInteractionClassWithRegions(ServiceUtilizationType.SubscribeInteractionClassWithRegions value) {
        this.subscribeInteractionClassWithRegions = value;
    }

    /**
     * Obtient la valeur de la propriété unsubscribeInteractionClassWithRegions.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.UnsubscribeInteractionClassWithRegions }
     *     
     */
    public ServiceUtilizationType.UnsubscribeInteractionClassWithRegions getUnsubscribeInteractionClassWithRegions() {
        return unsubscribeInteractionClassWithRegions;
    }

    /**
     * Définit la valeur de la propriété unsubscribeInteractionClassWithRegions.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.UnsubscribeInteractionClassWithRegions }
     *     
     */
    public void setUnsubscribeInteractionClassWithRegions(ServiceUtilizationType.UnsubscribeInteractionClassWithRegions value) {
        this.unsubscribeInteractionClassWithRegions = value;
    }

    /**
     * Obtient la valeur de la propriété sendInteractionWithRegions.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.SendInteractionWithRegions }
     *     
     */
    public ServiceUtilizationType.SendInteractionWithRegions getSendInteractionWithRegions() {
        return sendInteractionWithRegions;
    }

    /**
     * Définit la valeur de la propriété sendInteractionWithRegions.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.SendInteractionWithRegions }
     *     
     */
    public void setSendInteractionWithRegions(ServiceUtilizationType.SendInteractionWithRegions value) {
        this.sendInteractionWithRegions = value;
    }

    /**
     * Obtient la valeur de la propriété requestAttributeValueUpdateWithRegions.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.RequestAttributeValueUpdateWithRegions }
     *     
     */
    public ServiceUtilizationType.RequestAttributeValueUpdateWithRegions getRequestAttributeValueUpdateWithRegions() {
        return requestAttributeValueUpdateWithRegions;
    }

    /**
     * Définit la valeur de la propriété requestAttributeValueUpdateWithRegions.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.RequestAttributeValueUpdateWithRegions }
     *     
     */
    public void setRequestAttributeValueUpdateWithRegions(ServiceUtilizationType.RequestAttributeValueUpdateWithRegions value) {
        this.requestAttributeValueUpdateWithRegions = value;
    }

    /**
     * Obtient la valeur de la propriété getAutomaticResignDirective.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetAutomaticResignDirective }
     *     
     */
    public ServiceUtilizationType.GetAutomaticResignDirective getGetAutomaticResignDirective() {
        return getAutomaticResignDirective;
    }

    /**
     * Définit la valeur de la propriété getAutomaticResignDirective.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetAutomaticResignDirective }
     *     
     */
    public void setGetAutomaticResignDirective(ServiceUtilizationType.GetAutomaticResignDirective value) {
        this.getAutomaticResignDirective = value;
    }

    /**
     * Obtient la valeur de la propriété setAutomaticResignDirective.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.SetAutomaticResignDirective }
     *     
     */
    public ServiceUtilizationType.SetAutomaticResignDirective getSetAutomaticResignDirective() {
        return setAutomaticResignDirective;
    }

    /**
     * Définit la valeur de la propriété setAutomaticResignDirective.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.SetAutomaticResignDirective }
     *     
     */
    public void setSetAutomaticResignDirective(ServiceUtilizationType.SetAutomaticResignDirective value) {
        this.setAutomaticResignDirective = value;
    }

    /**
     * Obtient la valeur de la propriété getFederateHandle.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetFederateHandle }
     *     
     */
    public ServiceUtilizationType.GetFederateHandle getGetFederateHandle() {
        return getFederateHandle;
    }

    /**
     * Définit la valeur de la propriété getFederateHandle.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetFederateHandle }
     *     
     */
    public void setGetFederateHandle(ServiceUtilizationType.GetFederateHandle value) {
        this.getFederateHandle = value;
    }

    /**
     * Obtient la valeur de la propriété getFederateName.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetFederateName }
     *     
     */
    public ServiceUtilizationType.GetFederateName getGetFederateName() {
        return getFederateName;
    }

    /**
     * Définit la valeur de la propriété getFederateName.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetFederateName }
     *     
     */
    public void setGetFederateName(ServiceUtilizationType.GetFederateName value) {
        this.getFederateName = value;
    }

    /**
     * Obtient la valeur de la propriété getObjectClassHandle.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetObjectClassHandle }
     *     
     */
    public ServiceUtilizationType.GetObjectClassHandle getGetObjectClassHandle() {
        return getObjectClassHandle;
    }

    /**
     * Définit la valeur de la propriété getObjectClassHandle.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetObjectClassHandle }
     *     
     */
    public void setGetObjectClassHandle(ServiceUtilizationType.GetObjectClassHandle value) {
        this.getObjectClassHandle = value;
    }

    /**
     * Obtient la valeur de la propriété getObjectClassName.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetObjectClassName }
     *     
     */
    public ServiceUtilizationType.GetObjectClassName getGetObjectClassName() {
        return getObjectClassName;
    }

    /**
     * Définit la valeur de la propriété getObjectClassName.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetObjectClassName }
     *     
     */
    public void setGetObjectClassName(ServiceUtilizationType.GetObjectClassName value) {
        this.getObjectClassName = value;
    }

    /**
     * Obtient la valeur de la propriété getKnownObjectClassHandle.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetKnownObjectClassHandle }
     *     
     */
    public ServiceUtilizationType.GetKnownObjectClassHandle getGetKnownObjectClassHandle() {
        return getKnownObjectClassHandle;
    }

    /**
     * Définit la valeur de la propriété getKnownObjectClassHandle.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetKnownObjectClassHandle }
     *     
     */
    public void setGetKnownObjectClassHandle(ServiceUtilizationType.GetKnownObjectClassHandle value) {
        this.getKnownObjectClassHandle = value;
    }

    /**
     * Obtient la valeur de la propriété getObjectInstanceHandle.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetObjectInstanceHandle }
     *     
     */
    public ServiceUtilizationType.GetObjectInstanceHandle getGetObjectInstanceHandle() {
        return getObjectInstanceHandle;
    }

    /**
     * Définit la valeur de la propriété getObjectInstanceHandle.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetObjectInstanceHandle }
     *     
     */
    public void setGetObjectInstanceHandle(ServiceUtilizationType.GetObjectInstanceHandle value) {
        this.getObjectInstanceHandle = value;
    }

    /**
     * Obtient la valeur de la propriété getObjectInstanceName.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetObjectInstanceName }
     *     
     */
    public ServiceUtilizationType.GetObjectInstanceName getGetObjectInstanceName() {
        return getObjectInstanceName;
    }

    /**
     * Définit la valeur de la propriété getObjectInstanceName.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetObjectInstanceName }
     *     
     */
    public void setGetObjectInstanceName(ServiceUtilizationType.GetObjectInstanceName value) {
        this.getObjectInstanceName = value;
    }

    /**
     * Obtient la valeur de la propriété getAttributeHandle.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetAttributeHandle }
     *     
     */
    public ServiceUtilizationType.GetAttributeHandle getGetAttributeHandle() {
        return getAttributeHandle;
    }

    /**
     * Définit la valeur de la propriété getAttributeHandle.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetAttributeHandle }
     *     
     */
    public void setGetAttributeHandle(ServiceUtilizationType.GetAttributeHandle value) {
        this.getAttributeHandle = value;
    }

    /**
     * Obtient la valeur de la propriété getAttributeName.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetAttributeName }
     *     
     */
    public ServiceUtilizationType.GetAttributeName getGetAttributeName() {
        return getAttributeName;
    }

    /**
     * Définit la valeur de la propriété getAttributeName.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetAttributeName }
     *     
     */
    public void setGetAttributeName(ServiceUtilizationType.GetAttributeName value) {
        this.getAttributeName = value;
    }

    /**
     * Obtient la valeur de la propriété getUpdateRateValue.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetUpdateRateValue }
     *     
     */
    public ServiceUtilizationType.GetUpdateRateValue getGetUpdateRateValue() {
        return getUpdateRateValue;
    }

    /**
     * Définit la valeur de la propriété getUpdateRateValue.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetUpdateRateValue }
     *     
     */
    public void setGetUpdateRateValue(ServiceUtilizationType.GetUpdateRateValue value) {
        this.getUpdateRateValue = value;
    }

    /**
     * Obtient la valeur de la propriété getUpdateRateValueForAttribute.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetUpdateRateValueForAttribute }
     *     
     */
    public ServiceUtilizationType.GetUpdateRateValueForAttribute getGetUpdateRateValueForAttribute() {
        return getUpdateRateValueForAttribute;
    }

    /**
     * Définit la valeur de la propriété getUpdateRateValueForAttribute.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetUpdateRateValueForAttribute }
     *     
     */
    public void setGetUpdateRateValueForAttribute(ServiceUtilizationType.GetUpdateRateValueForAttribute value) {
        this.getUpdateRateValueForAttribute = value;
    }

    /**
     * Obtient la valeur de la propriété getInteractionClassHandle.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetInteractionClassHandle }
     *     
     */
    public ServiceUtilizationType.GetInteractionClassHandle getGetInteractionClassHandle() {
        return getInteractionClassHandle;
    }

    /**
     * Définit la valeur de la propriété getInteractionClassHandle.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetInteractionClassHandle }
     *     
     */
    public void setGetInteractionClassHandle(ServiceUtilizationType.GetInteractionClassHandle value) {
        this.getInteractionClassHandle = value;
    }

    /**
     * Obtient la valeur de la propriété getInteractionClassName.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetInteractionClassName }
     *     
     */
    public ServiceUtilizationType.GetInteractionClassName getGetInteractionClassName() {
        return getInteractionClassName;
    }

    /**
     * Définit la valeur de la propriété getInteractionClassName.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetInteractionClassName }
     *     
     */
    public void setGetInteractionClassName(ServiceUtilizationType.GetInteractionClassName value) {
        this.getInteractionClassName = value;
    }

    /**
     * Obtient la valeur de la propriété getParameterHandle.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetParameterHandle }
     *     
     */
    public ServiceUtilizationType.GetParameterHandle getGetParameterHandle() {
        return getParameterHandle;
    }

    /**
     * Définit la valeur de la propriété getParameterHandle.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetParameterHandle }
     *     
     */
    public void setGetParameterHandle(ServiceUtilizationType.GetParameterHandle value) {
        this.getParameterHandle = value;
    }

    /**
     * Obtient la valeur de la propriété getParameterName.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetParameterName }
     *     
     */
    public ServiceUtilizationType.GetParameterName getGetParameterName() {
        return getParameterName;
    }

    /**
     * Définit la valeur de la propriété getParameterName.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetParameterName }
     *     
     */
    public void setGetParameterName(ServiceUtilizationType.GetParameterName value) {
        this.getParameterName = value;
    }

    /**
     * Obtient la valeur de la propriété getOrderType.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetOrderType }
     *     
     */
    public ServiceUtilizationType.GetOrderType getGetOrderType() {
        return getOrderType;
    }

    /**
     * Définit la valeur de la propriété getOrderType.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetOrderType }
     *     
     */
    public void setGetOrderType(ServiceUtilizationType.GetOrderType value) {
        this.getOrderType = value;
    }

    /**
     * Obtient la valeur de la propriété getOrderName.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetOrderName }
     *     
     */
    public ServiceUtilizationType.GetOrderName getGetOrderName() {
        return getOrderName;
    }

    /**
     * Définit la valeur de la propriété getOrderName.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetOrderName }
     *     
     */
    public void setGetOrderName(ServiceUtilizationType.GetOrderName value) {
        this.getOrderName = value;
    }

    /**
     * Obtient la valeur de la propriété getTransportationTypeHandle.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetTransportationTypeHandle }
     *     
     */
    public ServiceUtilizationType.GetTransportationTypeHandle getGetTransportationTypeHandle() {
        return getTransportationTypeHandle;
    }

    /**
     * Définit la valeur de la propriété getTransportationTypeHandle.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetTransportationTypeHandle }
     *     
     */
    public void setGetTransportationTypeHandle(ServiceUtilizationType.GetTransportationTypeHandle value) {
        this.getTransportationTypeHandle = value;
    }

    /**
     * Obtient la valeur de la propriété getTransportationTypeName.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetTransportationTypeName }
     *     
     */
    public ServiceUtilizationType.GetTransportationTypeName getGetTransportationTypeName() {
        return getTransportationTypeName;
    }

    /**
     * Définit la valeur de la propriété getTransportationTypeName.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetTransportationTypeName }
     *     
     */
    public void setGetTransportationTypeName(ServiceUtilizationType.GetTransportationTypeName value) {
        this.getTransportationTypeName = value;
    }

    /**
     * Obtient la valeur de la propriété getAvailableDimensionsForClassAttribute.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetAvailableDimensionsForClassAttribute }
     *     
     */
    public ServiceUtilizationType.GetAvailableDimensionsForClassAttribute getGetAvailableDimensionsForClassAttribute() {
        return getAvailableDimensionsForClassAttribute;
    }

    /**
     * Définit la valeur de la propriété getAvailableDimensionsForClassAttribute.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetAvailableDimensionsForClassAttribute }
     *     
     */
    public void setGetAvailableDimensionsForClassAttribute(ServiceUtilizationType.GetAvailableDimensionsForClassAttribute value) {
        this.getAvailableDimensionsForClassAttribute = value;
    }

    /**
     * Obtient la valeur de la propriété getAvailableDimensionsForInteractionClass.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetAvailableDimensionsForInteractionClass }
     *     
     */
    public ServiceUtilizationType.GetAvailableDimensionsForInteractionClass getGetAvailableDimensionsForInteractionClass() {
        return getAvailableDimensionsForInteractionClass;
    }

    /**
     * Définit la valeur de la propriété getAvailableDimensionsForInteractionClass.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetAvailableDimensionsForInteractionClass }
     *     
     */
    public void setGetAvailableDimensionsForInteractionClass(ServiceUtilizationType.GetAvailableDimensionsForInteractionClass value) {
        this.getAvailableDimensionsForInteractionClass = value;
    }

    /**
     * Obtient la valeur de la propriété getDimensionHandle.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetDimensionHandle }
     *     
     */
    public ServiceUtilizationType.GetDimensionHandle getGetDimensionHandle() {
        return getDimensionHandle;
    }

    /**
     * Définit la valeur de la propriété getDimensionHandle.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetDimensionHandle }
     *     
     */
    public void setGetDimensionHandle(ServiceUtilizationType.GetDimensionHandle value) {
        this.getDimensionHandle = value;
    }

    /**
     * Obtient la valeur de la propriété getDimensionName.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetDimensionName }
     *     
     */
    public ServiceUtilizationType.GetDimensionName getGetDimensionName() {
        return getDimensionName;
    }

    /**
     * Définit la valeur de la propriété getDimensionName.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetDimensionName }
     *     
     */
    public void setGetDimensionName(ServiceUtilizationType.GetDimensionName value) {
        this.getDimensionName = value;
    }

    /**
     * Obtient la valeur de la propriété getDimensionUpperBound.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetDimensionUpperBound }
     *     
     */
    public ServiceUtilizationType.GetDimensionUpperBound getGetDimensionUpperBound() {
        return getDimensionUpperBound;
    }

    /**
     * Définit la valeur de la propriété getDimensionUpperBound.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetDimensionUpperBound }
     *     
     */
    public void setGetDimensionUpperBound(ServiceUtilizationType.GetDimensionUpperBound value) {
        this.getDimensionUpperBound = value;
    }

    /**
     * Obtient la valeur de la propriété getDimensionHandleSet.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetDimensionHandleSet }
     *     
     */
    public ServiceUtilizationType.GetDimensionHandleSet getGetDimensionHandleSet() {
        return getDimensionHandleSet;
    }

    /**
     * Définit la valeur de la propriété getDimensionHandleSet.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetDimensionHandleSet }
     *     
     */
    public void setGetDimensionHandleSet(ServiceUtilizationType.GetDimensionHandleSet value) {
        this.getDimensionHandleSet = value;
    }

    /**
     * Obtient la valeur de la propriété getRangeBounds.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.GetRangeBounds }
     *     
     */
    public ServiceUtilizationType.GetRangeBounds getGetRangeBounds() {
        return getRangeBounds;
    }

    /**
     * Définit la valeur de la propriété getRangeBounds.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.GetRangeBounds }
     *     
     */
    public void setGetRangeBounds(ServiceUtilizationType.GetRangeBounds value) {
        this.getRangeBounds = value;
    }

    /**
     * Obtient la valeur de la propriété setRangeBounds.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.SetRangeBounds }
     *     
     */
    public ServiceUtilizationType.SetRangeBounds getSetRangeBounds() {
        return setRangeBounds;
    }

    /**
     * Définit la valeur de la propriété setRangeBounds.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.SetRangeBounds }
     *     
     */
    public void setSetRangeBounds(ServiceUtilizationType.SetRangeBounds value) {
        this.setRangeBounds = value;
    }

    /**
     * Obtient la valeur de la propriété normalizeFederateHandle.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.NormalizeFederateHandle }
     *     
     */
    public ServiceUtilizationType.NormalizeFederateHandle getNormalizeFederateHandle() {
        return normalizeFederateHandle;
    }

    /**
     * Définit la valeur de la propriété normalizeFederateHandle.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.NormalizeFederateHandle }
     *     
     */
    public void setNormalizeFederateHandle(ServiceUtilizationType.NormalizeFederateHandle value) {
        this.normalizeFederateHandle = value;
    }

    /**
     * Obtient la valeur de la propriété normalizeServiceGroup.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.NormalizeServiceGroup }
     *     
     */
    public ServiceUtilizationType.NormalizeServiceGroup getNormalizeServiceGroup() {
        return normalizeServiceGroup;
    }

    /**
     * Définit la valeur de la propriété normalizeServiceGroup.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.NormalizeServiceGroup }
     *     
     */
    public void setNormalizeServiceGroup(ServiceUtilizationType.NormalizeServiceGroup value) {
        this.normalizeServiceGroup = value;
    }

    /**
     * Obtient la valeur de la propriété enableObjectClassRelevanceAdvisorySwitch.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.EnableObjectClassRelevanceAdvisorySwitch }
     *     
     */
    public ServiceUtilizationType.EnableObjectClassRelevanceAdvisorySwitch getEnableObjectClassRelevanceAdvisorySwitch() {
        return enableObjectClassRelevanceAdvisorySwitch;
    }

    /**
     * Définit la valeur de la propriété enableObjectClassRelevanceAdvisorySwitch.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.EnableObjectClassRelevanceAdvisorySwitch }
     *     
     */
    public void setEnableObjectClassRelevanceAdvisorySwitch(ServiceUtilizationType.EnableObjectClassRelevanceAdvisorySwitch value) {
        this.enableObjectClassRelevanceAdvisorySwitch = value;
    }

    /**
     * Obtient la valeur de la propriété disableObjectClassRelevanceAdvisorySwitch.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.DisableObjectClassRelevanceAdvisorySwitch }
     *     
     */
    public ServiceUtilizationType.DisableObjectClassRelevanceAdvisorySwitch getDisableObjectClassRelevanceAdvisorySwitch() {
        return disableObjectClassRelevanceAdvisorySwitch;
    }

    /**
     * Définit la valeur de la propriété disableObjectClassRelevanceAdvisorySwitch.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.DisableObjectClassRelevanceAdvisorySwitch }
     *     
     */
    public void setDisableObjectClassRelevanceAdvisorySwitch(ServiceUtilizationType.DisableObjectClassRelevanceAdvisorySwitch value) {
        this.disableObjectClassRelevanceAdvisorySwitch = value;
    }

    /**
     * Obtient la valeur de la propriété enableAttributeRelevanceAdvisorySwitch.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.EnableAttributeRelevanceAdvisorySwitch }
     *     
     */
    public ServiceUtilizationType.EnableAttributeRelevanceAdvisorySwitch getEnableAttributeRelevanceAdvisorySwitch() {
        return enableAttributeRelevanceAdvisorySwitch;
    }

    /**
     * Définit la valeur de la propriété enableAttributeRelevanceAdvisorySwitch.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.EnableAttributeRelevanceAdvisorySwitch }
     *     
     */
    public void setEnableAttributeRelevanceAdvisorySwitch(ServiceUtilizationType.EnableAttributeRelevanceAdvisorySwitch value) {
        this.enableAttributeRelevanceAdvisorySwitch = value;
    }

    /**
     * Obtient la valeur de la propriété disableAttributeRelevanceAdvisorySwitch.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.DisableAttributeRelevanceAdvisorySwitch }
     *     
     */
    public ServiceUtilizationType.DisableAttributeRelevanceAdvisorySwitch getDisableAttributeRelevanceAdvisorySwitch() {
        return disableAttributeRelevanceAdvisorySwitch;
    }

    /**
     * Définit la valeur de la propriété disableAttributeRelevanceAdvisorySwitch.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.DisableAttributeRelevanceAdvisorySwitch }
     *     
     */
    public void setDisableAttributeRelevanceAdvisorySwitch(ServiceUtilizationType.DisableAttributeRelevanceAdvisorySwitch value) {
        this.disableAttributeRelevanceAdvisorySwitch = value;
    }

    /**
     * Obtient la valeur de la propriété enableAttributeScopeAdvisorySwitch.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.EnableAttributeScopeAdvisorySwitch }
     *     
     */
    public ServiceUtilizationType.EnableAttributeScopeAdvisorySwitch getEnableAttributeScopeAdvisorySwitch() {
        return enableAttributeScopeAdvisorySwitch;
    }

    /**
     * Définit la valeur de la propriété enableAttributeScopeAdvisorySwitch.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.EnableAttributeScopeAdvisorySwitch }
     *     
     */
    public void setEnableAttributeScopeAdvisorySwitch(ServiceUtilizationType.EnableAttributeScopeAdvisorySwitch value) {
        this.enableAttributeScopeAdvisorySwitch = value;
    }

    /**
     * Obtient la valeur de la propriété disableAttributeScopeAdvisorySwitch.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.DisableAttributeScopeAdvisorySwitch }
     *     
     */
    public ServiceUtilizationType.DisableAttributeScopeAdvisorySwitch getDisableAttributeScopeAdvisorySwitch() {
        return disableAttributeScopeAdvisorySwitch;
    }

    /**
     * Définit la valeur de la propriété disableAttributeScopeAdvisorySwitch.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.DisableAttributeScopeAdvisorySwitch }
     *     
     */
    public void setDisableAttributeScopeAdvisorySwitch(ServiceUtilizationType.DisableAttributeScopeAdvisorySwitch value) {
        this.disableAttributeScopeAdvisorySwitch = value;
    }

    /**
     * Obtient la valeur de la propriété enableInteractionRelevanceAdvisorySwitch.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.EnableInteractionRelevanceAdvisorySwitch }
     *     
     */
    public ServiceUtilizationType.EnableInteractionRelevanceAdvisorySwitch getEnableInteractionRelevanceAdvisorySwitch() {
        return enableInteractionRelevanceAdvisorySwitch;
    }

    /**
     * Définit la valeur de la propriété enableInteractionRelevanceAdvisorySwitch.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.EnableInteractionRelevanceAdvisorySwitch }
     *     
     */
    public void setEnableInteractionRelevanceAdvisorySwitch(ServiceUtilizationType.EnableInteractionRelevanceAdvisorySwitch value) {
        this.enableInteractionRelevanceAdvisorySwitch = value;
    }

    /**
     * Obtient la valeur de la propriété disableInteractionRelevanceAdvisorySwitch.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.DisableInteractionRelevanceAdvisorySwitch }
     *     
     */
    public ServiceUtilizationType.DisableInteractionRelevanceAdvisorySwitch getDisableInteractionRelevanceAdvisorySwitch() {
        return disableInteractionRelevanceAdvisorySwitch;
    }

    /**
     * Définit la valeur de la propriété disableInteractionRelevanceAdvisorySwitch.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.DisableInteractionRelevanceAdvisorySwitch }
     *     
     */
    public void setDisableInteractionRelevanceAdvisorySwitch(ServiceUtilizationType.DisableInteractionRelevanceAdvisorySwitch value) {
        this.disableInteractionRelevanceAdvisorySwitch = value;
    }

    /**
     * Obtient la valeur de la propriété evokeCallback.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.EvokeCallback }
     *     
     */
    public ServiceUtilizationType.EvokeCallback getEvokeCallback() {
        return evokeCallback;
    }

    /**
     * Définit la valeur de la propriété evokeCallback.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.EvokeCallback }
     *     
     */
    public void setEvokeCallback(ServiceUtilizationType.EvokeCallback value) {
        this.evokeCallback = value;
    }

    /**
     * Obtient la valeur de la propriété evokeMultipleCallbacks.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.EvokeMultipleCallbacks }
     *     
     */
    public ServiceUtilizationType.EvokeMultipleCallbacks getEvokeMultipleCallbacks() {
        return evokeMultipleCallbacks;
    }

    /**
     * Définit la valeur de la propriété evokeMultipleCallbacks.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.EvokeMultipleCallbacks }
     *     
     */
    public void setEvokeMultipleCallbacks(ServiceUtilizationType.EvokeMultipleCallbacks value) {
        this.evokeMultipleCallbacks = value;
    }

    /**
     * Obtient la valeur de la propriété enableCallbacks.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.EnableCallbacks }
     *     
     */
    public ServiceUtilizationType.EnableCallbacks getEnableCallbacks() {
        return enableCallbacks;
    }

    /**
     * Définit la valeur de la propriété enableCallbacks.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.EnableCallbacks }
     *     
     */
    public void setEnableCallbacks(ServiceUtilizationType.EnableCallbacks value) {
        this.enableCallbacks = value;
    }

    /**
     * Obtient la valeur de la propriété disableCallbacks.
     * 
     * @return
     *     possible object is
     *     {@link ServiceUtilizationType.DisableCallbacks }
     *     
     */
    public ServiceUtilizationType.DisableCallbacks getDisableCallbacks() {
        return disableCallbacks;
    }

    /**
     * Définit la valeur de la propriété disableCallbacks.
     * 
     * @param value
     *     allowed object is
     *     {@link ServiceUtilizationType.DisableCallbacks }
     *     
     */
    public void setDisableCallbacks(ServiceUtilizationType.DisableCallbacks value) {
        this.disableCallbacks = value;
    }

    /**
     * Gets the value of the attrNotes property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAttrNotes().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Object }
     * 
     * 
     */
    public List<Object> getAttrNotes() {
        if (attrNotes == null) {
            attrNotes = new ArrayList<Object>();
        }
        return this.attrNotes;
    }

    /**
     * Obtient la valeur de la propriété idtag.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String }
     *     
     */
    public java.lang.String getIdtag() {
        return idtag;
    }

    /**
     * Définit la valeur de la propriété idtag.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String }
     *     
     */
    public void setIdtag(java.lang.String value) {
        this.idtag = value;
    }

    /**
     * Gets a map that contains attributes that aren't bound to any typed property on this class.
     * 
     * <p>
     * the map is keyed by the name of the attribute and 
     * the value is the string value of the attribute.
     * 
     * the map returned by this method is live, and you can add new attribute
     * by updating the map directly. Because of this design, there's no setter.
     * 
     * 
     * @return
     *     always non-null
     */
    public Map<QName, java.lang.String> getOtherAttributes() {
        return otherAttributes;
    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.30" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class AbortFederationRestore {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.30";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.21" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class AbortFederationSave {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.21";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.13" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class AnnounceSynchronizationPoint {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.13";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.6" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class AssociateRegionsForUpdates {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "9.6";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.8" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class AttributeOwnershipAcquisition {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "7.8";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.9" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class AttributeOwnershipAcquisitionIfAvailable {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "7.9";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.7" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class AttributeOwnershipAcquisitionNotification {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "7.7";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.13" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class AttributeOwnershipDivestitureIfWanted {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "7.13";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.12" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class AttributeOwnershipReleaseDenied {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "7.12";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.10" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class AttributeOwnershipUnavailable {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "7.10";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.17" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class AttributesInScope {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.17";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.18" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class AttributesOutOfScope {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.18";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.15" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class CancelAttributeOwnershipAcquisition {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "7.15";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.14" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class CancelNegotiatedAttributeOwnershipDivestiture {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "7.14";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.23" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ChangeAttributeOrderType {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.23";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.24" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ChangeInteractionOrderType {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.24";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.3" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class CommitRegionModifications {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "9.3";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.16" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ConfirmAttributeOwnershipAcquisitionCancellation {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "7.16";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.24" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ConfirmAttributeTransportationTypeChange {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.24";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.6" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ConfirmDivestiture {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "7.6";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.25" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ConfirmFederationRestorationRequest {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.25";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.28" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ConfirmInteractionTransportationTypeChange {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.28";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.12" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ConfirmSynchronizationPointRegistration {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.12";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.2" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class Connect {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.2";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.4" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ConnectionLost {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.4";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.5" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class CreateFederationExecution {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.5";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.2" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class CreateRegion {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "9.2";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.14" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class DeleteObjectInstance {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.14";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.4" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class DeleteRegion {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "9.4";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.6" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class DestroyFederationExecution {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.6";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.15" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class DisableAsynchronousDelivery {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.15";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.36" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class DisableAttributeRelevanceAdvisorySwitch {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.36";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.38" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class DisableAttributeScopeAdvisorySwitch {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.38";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.44" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class DisableCallbacks {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.44";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.40" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class DisableInteractionRelevanceAdvisorySwitch {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.40";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.34" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class DisableObjectClassRelevanceAdvisorySwitch {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.34";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.7" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class DisableTimeConstrained {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.7";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.4" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class DisableTimeRegulation {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.4";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.3" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class Disconnect {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.3";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.9" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class DiscoverObjectInstance {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.9";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.14" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class EnableAsynchronousDelivery {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.14";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.35" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class EnableAttributeRelevanceAdvisorySwitch {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.35";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.37" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class EnableAttributeScopeAdvisorySwitch {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.37";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.43" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class EnableCallbacks {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.43";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.39" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class EnableInteractionRelevanceAdvisorySwitch {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.39";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.33" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class EnableObjectClassRelevanceAdvisorySwitch {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.33";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.5" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class EnableTimeConstrained {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.5";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.2" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class EnableTimeRegulation {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.2";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.41" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class EvokeCallback {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.41";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.42" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class EvokeMultipleCallbacks {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.42";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.28" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class FederateRestoreComplete {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.28";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.18" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class FederateSaveBegun {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.18";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.19" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class FederateSaveComplete {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.19";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.26" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class FederationRestoreBegun {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.26";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.32" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class FederationRestoreStatusResponse {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.32";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.29" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class FederationRestored {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.29";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.23" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class FederationSaveStatusResponse {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.23";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.20" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class FederationSaved {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.20";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.15" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class FederationSynchronized {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.15";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.12" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class FlushQueueRequest {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.12";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.11" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetAttributeHandle {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.11";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.12" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetAttributeName {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.12";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.2" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetAutomaticResignDirective {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.2";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.23" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetAvailableDimensionsForClassAttribute {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.23";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.24" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetAvailableDimensionsForInteractionClass {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.24";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.25" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetDimensionHandle {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.25";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.28" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetDimensionHandleSet {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.28";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.26" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetDimensionName {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.26";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.27" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetDimensionUpperBound {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.27";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.4" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetFederateHandle {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.4";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.5" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetFederateName {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.5";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.15" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetInteractionClassHandle {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.15";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.16" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetInteractionClassName {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.16";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.8" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetKnownObjectClassHandle {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.8";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.6" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetObjectClassHandle {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.6";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.7" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetObjectClassName {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.7";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.9" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetObjectInstanceHandle {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.9";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.10" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetObjectInstanceName {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.10";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.20" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetOrderName {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.20";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.19" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetOrderType {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.19";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.17" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetParameterHandle {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.17";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.18" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetParameterName {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.18";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.29" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetRangeBounds {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.29";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.21" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetTransportationTypeHandle {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.21";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.22" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetTransportationTypeName {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.22";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.13" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetUpdateRateValue {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.13";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.14" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class GetUpdateRateValueForAttribute {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.14";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.18" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class InformAttributeOwnership {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "7.18";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.27" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class InitiateFederateRestore {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.27";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.17" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class InitiateFederateSave {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.17";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.19" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class IsAttributeOwnedByFederate {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "7.19";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.9" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class JoinFederationExecution {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.9";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.7" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ListFederationExecutions {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.7";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.16" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class LocalDeleteObjectInstance {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.16";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.19" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ModifyLookahead {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.19";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.6" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class MultipleObjectInstanceNamesReserved {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.6";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.3" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class NegotiatedAttributeOwnershipDivestiture {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "7.3";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.10" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class NextMessageRequest {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.10";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.11" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class NextMessageRequestAvailable {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.11";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.31" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class NormalizeFederateHandle {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.31";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.32" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class NormalizeServiceGroup {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.32";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.3" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ObjectInstanceNameReserved {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.3";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.20" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ProvideAttributeValueUpdate {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.20";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.4" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class PublishInteractionClass {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "5.4";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.2" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class PublishObjectClassAttributes {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "5.2";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.17" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class QueryAttributeOwnership {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "7.17";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.25" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class QueryAttributeTransportationType {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.25";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.31" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class QueryFederationRestoreStatus {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.31";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.22" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class QueryFederationSaveStatus {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.22";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.16" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class QueryGALT {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.16";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.29" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class QueryInteractionTransportationType {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.29";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.18" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class QueryLITS {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.18";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.17" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class QueryLogicalTime {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.17";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.20" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class QueryLookahead {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.20";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.13" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ReceiveInteraction {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.13";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.11" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ReflectAttributeValues {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.11";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.11" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class RegisterFederationSynchronizationPoint {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.11";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.8" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class RegisterObjectInstance {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.8";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.5" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class RegisterObjectInstanceWithRegions {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "9.5";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.7" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ReleaseMultipleObjectInstanceNames {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.7";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.4" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ReleaseObjectInstanceName {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.4";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.15" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class Removeobjectinstance {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.15";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.26" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ReportAttributeTransportationType {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.26";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.8" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ReportFederationExecutions {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.8";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.30" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ReportInteractionTransportationType {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.30";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.4" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class RequestAttributeOwnershipAssumption {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "7.4";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.11" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class RequestAttributeOwnershipRelease {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "7.11";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.23" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class RequestAttributeTransportationTypeChange {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.23";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.19" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class RequestAttributeValueUpdate {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.19";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.13" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class RequestAttributeValueUpdateWithRegions {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "9.13";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.5" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class RequestDivestitureConfirmation {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "7.5";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.24" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class RequestFederationRestore {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.24";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.16" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class RequestFederationSave {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.16";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.27" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class RequestInteractionTransportationTypeChange {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.27";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.22" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class RequestRetraction {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.22";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.5" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ReserveMultipleObjectInstanceNames {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.5";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.2" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ReserveObjectInstanceName {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.2";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.10" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class ResignFederationExecution {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.10";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.21" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class Retract {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.21";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.12" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class SendInteraction {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.12";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.12" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class SendInteractionWithRegions {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "9.12";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.3" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class SetAutomaticResignDirective {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.3";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="10.30" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class SetRangeBounds {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "10.30";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.10" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class StartRegistrationForObjectClass {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "5.10";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.11" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class StopRegistrationForObjectClass {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "5.11";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.8" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class SubscribeInteractionClass {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "5.8";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.10" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class SubscribeInteractionClassWithRegions {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "9.10";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.6" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class SubscribeObjectClassAttributes {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "5.6";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.8" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class SubscribeObjectClassAttributesWithRegions {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "9.8";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="4.14" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class SynchronizationPointAchieved {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "4.14";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.13" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class TimeAdvanceGrant {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.13";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.8" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class TimeAdvanceRequest {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.8";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.9" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class TimeAdvanceRequestAvailable {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.9";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.6" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class TimeConstrainedEnabled {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.6";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="8.3" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class TimeRegulationEnabled {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "8.3";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.13" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class TurnInteractionsOff {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "5.13";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.12" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class TurnInteractionsOn {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "5.12";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.22" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class TurnUpdatesOffForObjectInstance {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.22";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.21" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="true" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class TurnUpdatesOnForObjectInstance {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.21";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "true";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.7" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class UnassociateRegionsForUpdates {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "9.7";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="7.2" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class UnconditionalAttributeOwnershipDivestiture {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "7.2";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.5" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class UnpublishInteractionClass {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "5.5";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.3" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class UnpublishObjectClassAttributes {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "5.3";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.9" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class UnsubscribeInteractionClass {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "5.9";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.11" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class UnsubscribeInteractionClassWithRegions {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "9.11";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="5.7" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class UnsubscribeObjectClassAttributes {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "5.7";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="9.9" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class UnsubscribeObjectClassAttributesWithRegions {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "9.9";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }


    /**
     * <p>Classe Java pour anonymous complex type.
     * 
     * <p>Le fragment de schéma suivant indique le contenu attendu figurant dans cette classe.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;attGroup ref="{http://standards.ieee.org/IEEE1516-2010}commonAttributes"/>
     *       &lt;attribute name="section" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="6.10" />
     *       &lt;attribute name="isCallback" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" fixed="false" />
     *       &lt;attribute name="isUsed" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       &lt;anyAttribute namespace='##other'/>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class UpdateAttributeValues {

        @XmlAttribute(name = "section", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String section;
        @XmlAttribute(name = "isCallback", required = true)
        @XmlSchemaType(name = "anySimpleType")
        protected java.lang.String isCallback;
        @XmlAttribute(name = "isUsed")
        protected Boolean isUsed;
        @XmlAttribute(name = "notes")
        @XmlIDREF
        @XmlSchemaType(name = "IDREFS")
        protected List<Object> attrNotes;
        @XmlAttribute(name = "idtag")
        @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
        @XmlID
        @XmlSchemaType(name = "ID")
        protected java.lang.String idtag;
        @XmlAnyAttribute
        private Map<QName, java.lang.String> otherAttributes = new HashMap<QName, java.lang.String>();

        /**
         * Obtient la valeur de la propriété section.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getSection() {
            if (section == null) {
                return "6.10";
            } else {
                return section;
            }
        }

        /**
         * Définit la valeur de la propriété section.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setSection(java.lang.String value) {
            this.section = value;
        }

        /**
         * Obtient la valeur de la propriété isCallback.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIsCallback() {
            if (isCallback == null) {
                return "false";
            } else {
                return isCallback;
            }
        }

        /**
         * Définit la valeur de la propriété isCallback.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIsCallback(java.lang.String value) {
            this.isCallback = value;
        }

        /**
         * Obtient la valeur de la propriété isUsed.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isIsUsed() {
            if (isUsed == null) {
                return false;
            } else {
                return isUsed;
            }
        }

        /**
         * Définit la valeur de la propriété isUsed.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setIsUsed(Boolean value) {
            this.isUsed = value;
        }

        /**
         * Gets the value of the attrNotes property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the attrNotes property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAttrNotes().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAttrNotes() {
            if (attrNotes == null) {
                attrNotes = new ArrayList<Object>();
            }
            return this.attrNotes;
        }

        /**
         * Obtient la valeur de la propriété idtag.
         * 
         * @return
         *     possible object is
         *     {@link java.lang.String }
         *     
         */
        public java.lang.String getIdtag() {
            return idtag;
        }

        /**
         * Définit la valeur de la propriété idtag.
         * 
         * @param value
         *     allowed object is
         *     {@link java.lang.String }
         *     
         */
        public void setIdtag(java.lang.String value) {
            this.idtag = value;
        }

        /**
         * Gets a map that contains attributes that aren't bound to any typed property on this class.
         * 
         * <p>
         * the map is keyed by the name of the attribute and 
         * the value is the string value of the attribute.
         * 
         * the map returned by this method is live, and you can add new attribute
         * by updating the map directly. Because of this design, there's no setter.
         * 
         * 
         * @return
         *     always non-null
         */
        public Map<QName, java.lang.String> getOtherAttributes() {
            return otherAttributes;
        }

    }

}
